; Kuin Editor
; (C)Kuina-chan

func [d0917.knd, InitCompiler] initCompiler(memNum: int, lang: int)
end func

func [d0917.knd, FinCompiler] finCompiler()
end func

func [d0917.knd, BuildMem] build(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, output: []char, icon: []char, rls_: bool, env: []char, funcLog: func<([][]char, int, int)>, lang: int): bool
end func

func [d0917.knd, Interpret1] interpret1(src: [][]char, color: [][]bit8)
end func

func [d0917.knd, Interpret2] interpret2(path: []char, funcGetSrc: func<([]char): [][]char>, sysDir: []char, env: []char, funcLog: func<([][]char, int, int)>, lang: int, blankMem: int): bool
end func

func [d0917.knd, Version] version(major: &int, minor: &int, micro: &int)
end func

func [d0917.knd, ResetMemAllocator] resetMemAllocator(memIdx: int)
end func

func [d0917.knd, ResetHint] resetHint()
end func

func [d0917.knd, GetHint] getHint(src: []char, row: int, col: int, keyword: []char): []char
end func

func [d0917.knd, RunDbg] runDbg(name: []char, cmdLine: []char, idleFunc: func<()>, eventFunc: func<(int, []char): int>): bool
end func

var wndMain: wnd@Wnd
var treeItem: wnd@Tree
var listInfo: wnd@List
var editFile: wnd@Edit
var drawEditor: wnd@Draw
var scrollXSrc: wnd@ScrollX
var scrollYSrc: wnd@ScrollY
var editHint: wnd@EditMulti
var editLog: wnd@EditMulti
var btnCompile: wnd@Btn
var groupEnv: wnd@Group
var radioEnvWnd: wnd@Radio
var radioEnvCui: wnd@Radio
var btnRls: wnd@Btn
var listFile: wnd@List
var menuMain: wnd@Menu
var popupMainEdit: wnd@Popup
var popupMainFile: wnd@Popup
var popupMainBuild: wnd@Popup
var popupMainHelp: wnd@Popup
var tabOrderFind: wnd@TabOrder

class Pos()
	+var src: []char
	+var row: int
	+var col: int

	+*func cmp(t: Pos): int
		var result: int :: lib@cmp(me.src, t.src)
		if(result <> 0)
			ret result
		end if
		do result :: me.row - t.row
		if(result <> 0)
			ret result
		end if
		ret me.col - t.col
	end func
end class

class ListInfoItem()
	+var text: []char
	+var pos: @Pos

	+*func cmp(t: ListInfoItem): int
		ret me.pos.cmp(t.pos)
	end func
end class

class DocumentsClass()
	+var documents: dict<[]char, @Document>
end class

class UndoCmd(undo@Cmd)
	+var document: @Document
end class

class Document()
	+func init(src: [][]char)
		do me.initVars()
	end func

	+func getSrc(): [][]char
	end func

	+func draw(width: int, height: int)
	end func

	+func mouseDownL(x: int, y: int)
	end func

	+func mouseUpL(x: int, y: int)
	end func

	+func mouseMove(x: int, y: int)
	end func

	+func focus(isFocus: bool)
	end func

	+func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	end func

	+func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	end func

	+func keyChar(key: char)
	end func

	+func scrollX(pos: int)
	end func

	+func scrollY(pos: int)
	end func

	+func wheelX(wheel: int)
	end func

	+func wheelY(wheel: int)
	end func

	+func cmdUndo()
	end func

	+func cmdRedo()
	end func

	+func cmdCut()
	end func

	+func cmdCopy()
	end func

	+func cmdPaste()
	end func

	+func cmdDel()
	end func

	+func cmdSelAll()
	end func

	+func findPrev(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
	end func

	+func findNext(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
	end func

	+func replaceOne(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	end func

	+func replaceAll(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): int
	end func

	+func undoImpl(undo2: @UndoCmd)
	end func

	+var changed: bool
	var undo: undo@Undo

	func initVars()
		do me.undo :: #undo@Undo
		do me.undo.init(1024)
		do me.changed :: false
	end func
end class

class DocumentSrc(@Document)
	+*func init(src: [][]char)
		do me.initVars()
		do me.src :: #Src
		if(src =& null | ^src = 0)
			do me.src.src :: [""]
			do me.src.color :: [#[0]bit8]
		else
			do me.src.src :: src
			do me.src.color :: #[^src][]bit8
			for i(0, ^src - 1)
				do me.src.color[i] :: #[^src[i]]bit8
			end for
		end if
		do me.pageX :: 0
		do me.pageY :: 0
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		do me.lineNumberWidth :: 0
		do me.interpreted :: false
	end func

	+*func getSrc(): [][]char
		ret me.src.src
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, @colorBack)
		var lineX: float :: (me.lineNumberWidth - 2) $ float
		do draw@line(lineX, 0.0, lineX, height $ float, colorLineNumber)
		for i(0, ^me.src.src - 1)
			var y: float :: (i * @cellHeight) $ float
			if(y < -@cellHeight $ float | y >= (height + @cellHeight) $ float)
				skip i
			end if
			var str: []char :: (me.pageY + i + 1).toStr()
			do @font.draw((me.lineNumberWidth - (^str + 1) * @cellWidth + @cellWidth / 2) $ float, y, str, colorLineNumber)
		end for

		var areaX1: int :: me.areaX
		var areaY1: int :: me.areaY
		var areaX2: int :: me.cursorX
		var areaY2: int :: me.cursorY
		if(me.areaSelected() & (areaY1 > areaY2 | areaY1 = areaY2 & areaX1 > areaX2))
			do areaX1 :$ areaX2
			do areaY1 :$ areaY2
		end if
		for i(0, height / @cellHeight)
			if(me.pageY + i >= ^me.src.src)
				break i
			end if
			var str: []char :: me.src.src[me.pageY + i]
			var left: int :: me.lineNumberWidth - me.pageX * @cellWidth
			var x: int :: 0
			for j(0, ^str)
				assert j = ^str | str[j] <> 16#01 $ char & str[j] <> '\n'
				var x2: int :: left + x * @cellWidth
				if(x2 >= width)
					break j
				end if
				if(x2 >= me.lineNumberWidth)
					var inArea: bool :: false
					if(me.areaSelected())
						var areaX3: int :: j
						var areaY3: int :: me.pageY + i
						if (areaY3 < areaY1 | areaY2 < areaY3)
							; Do nothing.
						elif(areaY1 < areaY3 & areaY3 < areaY2)
							do inArea :: true
						elif(areaY1 = areaY2)
							do inArea :: areaX1 <= areaX3 & areaX3 < areaX2
						elif(areaY3 = areaY1)
							do inArea :: areaX1 <= areaX3
						else
							assert areaY3 = areaY2
							do inArea :: areaX3 < areaX2
						end if
					end if
					var textX: float :: x2 $ float
					var textY: float :: (i * @cellHeight) $ float
					if(j = ^str)
						if(inArea)
							do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorAreaBack)
						end if
						; TODO: Return mark.
					elif(inArea)
						do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorAreaBack)
						do @font.draw(textX, textY, str[j].toStr(), draw@white)
					elif(me.src.color[me.pageY + i][j].and(16#80b8) <> 0 $ @CharColor $ bit8)
						do draw@rect(textX, textY, @cellWidth $ float, @cellHeight $ float, colorErrBack)
						do @font.draw(textX, textY, str[j].toStr(), draw@white)
					else
						do @font.draw(textX, textY, str[j].toStr(), @srcCharColor[me.src.color[me.pageY + i][j].and(16#7Fb8) $ int])
					end if
				end if
				if(j <> ^str)
					do x :+ me.charWidth(str[j], x)
				end if
			end for
		end for
	end func

	+*func mouseDownL(x: int, y: int)
		do me.setArea(wnd@key(%shift) ?(%shift $ wnd@ShiftCtrl, %none))
		do me.mousePosToCharPos(x, y)
		do me.refreshCursor(false, true)
		if(!me.areaSelected())
			do me.areaX :: me.cursorX
			do me.areaY :: me.cursorY
		end if
		do @drawEditor.paint()
	end func

	+*func mouseUpL(x: int, y: int)
		do me.refreshCursor(false, true)
	end func

	+*func mouseMove(x: int, y: int)
		if(@drag)
			do me.mousePosToCharPos(x, y)
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do @drawEditor.showCaret(@cellHeight, @font)
			do me.refreshCursor(false, true)
		else
			do @drawEditor.hideCaret()
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		switch(key)
		case %bs
			if (@lockingEditor)
				do @showMsgRunning()
				ret
			end if
			if(shiftCtrl = %none)
				do me.undo.recordBegin()
				if(me.areaSelected())
					do me.delAreaStr()
				else
					do me.bs(me.cursorX, me.cursorY, 1, true)
				end if
				do me.undo.recordEnd()
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %tab
			switch(shiftCtrl)
			case %none
				if (@lockingEditor)
					do @showMsgRunning()
					ret
				end if
				if(!me.areaSelected())
					do me.undo.recordBegin()
					do me.ins(me.cursorX, me.cursorY, "\t", true)
					do me.undo.recordEnd()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				else
					do me.indentAreaStr()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				end if
			case %shift
				if (@lockingEditor)
					do @showMsgRunning()
					ret
				end if
				if(me.areaSelected())
					do me.unindentAreaStr()
					do me.refreshCursor(false, true)
					do @drawEditor.paint()
				end if
			end switch
		case %enter
			if (@lockingEditor)
				do @showMsgRunning()
				ret
			end if
			if(shiftCtrl = %none)
				do me.undo.recordBegin()
				if(me.areaSelected())
					do me.delAreaStr()
				end if
				block
					var str: []char :: "\n"
					for i(0, ^me.src.src[me.cursorY] - 1)
						if(me.src.src[me.cursorY][i] = '\t')
							do str :~ "\t"
						else
							break i
						end if
					end for
					do me.ins(me.cursorX, me.cursorY, str, true)
				end block
				do me.undo.recordEnd()
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
			end if
		case %pageUp
			block
				var height: int
				do @drawEditor.getPos(&, &, &, &height)
				if(shiftCtrl = %ctrl)
					do me.scrollPageY(-height / @cellHeight)
				else
					do me.setArea(shiftCtrl)
					var absoluteX: int :: me.getAbsoluteX()
					do me.cursorY :- height / @cellHeight
					do me.setAbsoluteX(absoluteX)
					do me.refreshCursor(false, true)
				end if
			end block
		case %pageDown
			block
				var height: int
				do @drawEditor.getPos(&, &, &, &height)
				if(shiftCtrl = %ctrl)
					do me.scrollPageY(height / @cellHeight)
				else
					do me.setArea(shiftCtrl)
					var absoluteX: int :: me.getAbsoluteX()
					do me.cursorY :+ height / @cellHeight
					do me.setAbsoluteX(absoluteX)
					do me.refreshCursor(false, true)
				end if
			end block
		case %end_
			do me.setArea(shiftCtrl)
			do me.cursorX :: lib@intMax
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: lib@intMax
			end if
			do me.refreshCursor(false, true)
		case %home
			do me.setArea(shiftCtrl)
			do me.cursorX :: 0
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: 0
			end if
			do me.refreshCursor(false, true)
		case %left
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(-1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :- 1
				do me.refreshCursor(false, true)
			end if
		case %up
			if(shiftCtrl = %ctrl)
				do me.scrollPageY(-1)
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :- 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
			end if
		case %right
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :+ 1
				do me.refreshCursor(true, true)
			end if
		case %down
			if(shiftCtrl = %ctrl)
				do me.scrollPageY(1)
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :+ 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true)
			end if
		case %ins
			; TODO: Insert mode.
		end switch
	end func

	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		do @drawEditor.paint()
	end func

	+*func keyChar(key: char)
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if(key = '\t' | me.charWidth(key, 0) = 0)
			ret
		end if
		do me.undo.recordBegin()
		if(me.areaSelected())
			do me.delAreaStr()
		end if
		do me.ins(me.cursorX, me.cursorY, [key], true)
		do me.undo.recordEnd()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos
		do me.refreshCursor(false, false)
		do @drawEditor.paint()
	end func

	+*func wheelX(wheel: int)
		do me.scrollPageX(wheel)
	end func

	+*func wheelY(wheel: int)
		do me.scrollPageY(wheel * 3)
	end func

	+*func cmdUndo()
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if(me.areaSelected())
			do me.areaX :: -1
		end if
		do me.undo.undo()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdRedo()
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if(me.areaSelected())
			do me.areaX :: -1
		end if
		do me.undo.redo()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdCut()
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if(me.areaSelected())
			do me.copyAreaStr()
			do me.undo.recordBegin()
			do me.delAreaStr()
			do me.undo.recordEnd()
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func cmdCopy()
		if(me.areaSelected())
			do me.copyAreaStr()
		end if
	end func

	+*func cmdPaste()
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		var str: []char :: wnd@getClipboardStr()
		if(str <>& null)
			do me.undo.recordBegin()
			if(me.areaSelected())
				do me.delAreaStr()
			end if
			do me.ins(me.cursorX, me.cursorY, str, true)
			do me.undo.recordEnd()
			do me.refreshCursor(false, true)
			do @drawEditor.paint()
		end if
	end func

	+*func cmdDel()
		if (@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		do me.undo.recordBegin()
		if(me.areaSelected())
			do me.delAreaStr()
		else
			do me.del(me.cursorX, me.cursorY, 1, true)
		end if
		do me.undo.recordEnd()
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func cmdSelAll()
		do me.areaX :: 0
		do me.areaY :: 0
		do me.cursorX :: lib@intMax
		do me.cursorY :: lib@intMax
		do me.refreshCursor(false, true)
		do @drawEditor.paint()
	end func

	+*func findPrev(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		var findBeginX: int :: (me.areaX <> -1 & me.areaX < me.cursorX ?(me.areaX, me.cursorX))
		var findBeginY: int :: me.cursorY
		var pos: int
		var found: []char
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret false
			end if
		end if
		for i(findBeginY, 0, -1)
			do pos :: @findStr(&found, me.src.src[i], true, 0, i = findBeginY ?(findBeginX - 1, ^me.src.src[i] - 1), pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
				ret true
			end if
		end for
		for i(^me.src.src - 1, findBeginY, -1)
			do pos :: @findStr(&found, me.src.src[i], true, i = findBeginY ?(findBeginX, 0), ^me.src.src[i] - 1, pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
				ret true
			end if
		end for
		ret false
	end func

	+*func findNext(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		var findBeginX: int :: (me.areaX <> -1 & me.areaX > me.cursorX ?(me.areaX, me.cursorX))
		var findBeginY: int :: me.cursorY
		var pos: int
		var found: []char
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret false
			end if
		end if
		for i(findBeginY, ^me.src.src - 1)
			do pos :: @findStr(&found, me.src.src[i], false, i = findBeginY ?(findBeginX, 0), ^me.src.src[i] - 1, pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
				ret true
			end if
		end for
		for i(0, findBeginY)
			do pos :: @findStr(&found, me.src.src[i], false, 0, i = findBeginY ?(findBeginX - 1, ^me.src.src[i] - 1), pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.refreshCursor(false, true)
				do @drawEditor.paint()
				ret true
			end if
		end for
		ret false
	end func

	+*func replaceOne(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
		if(!me.areaSelected() | me.areaY <> me.cursorY)
			ret
		end if
		var x1: int :: me.areaX
		var x2: int :: me.cursorX
		if(x1 > x2)
			do x1 :$ x2
		end if
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret
			end if
		end if
		var found: []char
		var pos: int :: @findStr(&found, me.src.src[me.cursorY], false, x1, x1, pattern, distinguishCase, onlyWord, regex)
		if(pos = x1)
			if(regex <>& null)
				do replaceStr :: regex.replace(found, replaceStr, false)
			end if
			do me.undo.recordBegin()
			do me.del(x1, me.cursorY, ^found, true)
			do me.ins(x1, me.cursorY, replaceStr, true)
			do me.undo.recordEnd()
		end if
	end func

	+*func replaceAll(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): int
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		var cnt: int :: 0
		while loop(true)
			var oldX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var oldY: int :: me.cursorY
			if(!me.findNext(pattern, distinguishCase, onlyWord, regularExpression))
				break loop
			end if
			var newX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var newY: int :: me.cursorY
			if(newY < oldY | newY = oldY & newX <= oldX)
				break loop
			end if
			do me.replaceOne(pattern, replaceStr, distinguishCase, onlyWord, regularExpression)
			do cnt :+ 1
		end while
		ret cnt
	end func

	+*func undoImpl(undo2: @UndoCmd)
		if(undo2 =$ UndoSrcIns)
			block
				var undo3: UndoSrcIns :: undo2 $ UndoSrcIns
				do me.ins(undo3.x, undo3.y, undo3.str, false)
			end block
		elif(undo2 =$ UndoSrcBsDel)
			block
				var undo3: UndoSrcBsDel :: undo2 $ UndoSrcBsDel
				switch(undo3.kind)
				case 0
					do me.bs(undo3.x, undo3.y, undo3.len, false)
				case 1
					do me.del(undo3.x, undo3.y, undo3.len, false)
				default
					assert false
				end switch
			end block
		else
			assert false
		end if
	end func

	+func showHint()
		var x: int :: me.cursorX
		if(^me.src.src[me.cursorY] = x)
			do x :- 1
		end if
		if(x < 0)
			ret
		end if
		while(x > 0 & (me.src.src[me.cursorY][x] = ' ' | me.src.src[me.cursorY][x] = '\t'))
			do x :- 1
		end while
		var srcName: []char :: @srcNameToInternalName(@getDocumentName(@curDocument))
		if(^me.src.src[me.cursorY] > 0 & me.src.src[me.cursorY][x] <> ' ' & me.src.src[me.cursorY][x] <> '\t')
			if(srcName <>& null)
				var color: @CharColor :: me.src.color[me.cursorY][x].and(16#7Fb8) $ @CharColor
				var last: int :: x
				while(x > 0 & me.src.color[me.cursorY][x - 1].and(16#7Fb8) = color $ bit8)
					do x :- 1
				end while
				var last2: int :: last
				while(last2 < ^me.src.color[me.cursorY] - 1 & me.src.color[me.cursorY][last2 + 1].and(16#7Fb8) = color $ bit8)
					do last2 :+ 1
				end while
				var word: []char :: me.src.src[me.cursorY].sub(x, last2 - x).trim()
				var hint: []char :: @getHint2(srcName, me.cursorY + 1, last, word)
				if(hint =& null)
					do hint :: ""
				end if
				if(@textHint <> hint)
					do @textHint :: hint
					do @updateLog()
				end if
			end if
		else
			if(@textHint <> "")
				do @textHint :: ""
				do @updateLog()
			end if
		end if
		do me.getFuncHint(srcName, x, me.cursorY)
	end func

	+func move(col: int, row: int)
		do me.cursorX :: col
		do me.cursorY :: row
		do me.refreshCursor(false, true)
	end func

	const colorLineNumber: int :: 16#FFFF7F7F
	const colorAreaBack: int :: 16#FF808080
	const colorErrBack: int :: 16#FFFF3333

	class Src()
		+var src: [][]char
		+var color: [][]bit8
	end class

	class UndoSrc(@UndoCmd)
		+*func cmd()
			do me.document.undoImpl(me)
		end func
	end class

	class UndoSrcIns(UndoSrc)
		+var x: int
		+var y: int
		+var str: []char
	end class

	class UndoSrcBsDel(UndoSrc)
		+var kind: int {0=bs, 1=del}
		+var x: int
		+var y: int
		+var len: int
	end class

	class UndoSrcReplaceAll(UndoSrc)
		+var x: []int
		+var y: []int
		+var len: []int
		+var str: [][]char
	end class

	+var src: Src
	var pageX: int
	var pageY: int
	var cursorX: int
	var cursorY: int
	var areaX: int
	var areaY: int
	var lineNumberWidth: int
	+var interpreted: bool

	func areaSelected(): bool
		ret me.areaX <> -1 & (me.areaX <> me.cursorX | me.areaY <> me.cursorY)
	end func

	func charWidth(c: char, x: int): int
		if(c = '\t')
			ret 4 - x % 4
		elif(c $ int <= 16#1F)
			ret 0
		elif(c $ int <= 16#7E)
			ret 1
		elif(c $ int <= 16#A0)
			ret 0
		end if
		ret 2
	end func

	func setArea(shiftCtrl: wnd@ShiftCtrl)
		if(shiftCtrl.and(%shift) <> %none)
			if(!me.areaSelected())
				do me.areaX :: me.cursorX
				do me.areaY :: me.cursorY
			end if
			do @drawEditor.paint()
		else
			if(me.areaX <> -1)
				do me.areaX :: -1
				do @drawEditor.paint()
			end if
		end if
	end func

	func mousePosToCharPos(mouseX: int, mouseY: int)
		do me.cursorY :: me.pageY + mouseY / @cellHeight
		if(me.cursorY >= ^me.src.src)
			do me.cursorX :: 0
			ret
		end if
		var left: int :: me.lineNumberWidth - me.pageX * @cellWidth
		var x: int :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(mouseX < left + (x + charWidth2) * @cellWidth)
				do me.cursorX :: i
				ret
			end if
			do x :+ charWidth2
		end for
		do me.cursorX :: ^me.src.src[me.cursorY]
	end func

	func refreshCursor(moveRight: bool, refreshScroll: bool)
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		do me.lineNumberWidth :: @cellWidth * (log10(^me.src.src) + 1)

		if(me.cursorX < 0)
			do me.cursorX :: lib@intMax
			do me.cursorY :- 1
		end if
		if(me.cursorY < 0)
			do me.cursorX :: 0
			do me.cursorY :: 0
		end if
		if(me.cursorY > ^me.src.src - 1)
			do me.cursorY :: ^me.src.src - 1
			do me.cursorX :: ^me.src.src[me.cursorY]
		else
			if(me.cursorX > ^me.src.src[me.cursorY])
				if(moveRight & me.cursorY <> ^me.src.src - 1)
					do me.cursorX :: 0
					do me.cursorY :+ 1
				else
					do me.cursorX :: ^me.src.src[me.cursorY]
				end if
			end if
		end if
		if(!@drag & me.areaX = me.cursorX & me.areaY = me.cursorY)
			do me.areaX :: -1
		end if

		if(refreshScroll)
			var paint: bool :: false
			var paddingX: int :: (me.lineNumberWidth + 17) / @cellWidth + 1
			const paddingY: int :: 17 / @cellHeight + 1
			if(me.pageY > me.cursorY)
				do me.pageY :: me.cursorY
				do paint :: true
			end if
			if(me.pageY < me.cursorY - scrHeight / @cellHeight + paddingY + 1)
				do me.pageY :: me.cursorY - scrHeight / @cellHeight + paddingY + 1
				do paint :: true
			end if
			do @scrollYSrc.setState(0, ^me.src.src - 1 + paddingY, scrHeight / @cellHeight, me.pageY)
			var maxX: int :: 0
			for i(0, scrHeight / @cellHeight + 1)
				if(me.pageY + i >= ^me.src.src)
					break i
				end if
				var x: int :: 0
				var str: []char :: me.src.src[me.pageY + i]
				for j(0, ^str - 1)
					do x :+ me.charWidth(str[j], x)
				end for
				if(maxX < x)
					do maxX :: x
				end if
			end for
			block
				var x: int :: 0
				for i(0, ^me.src.src[me.cursorY] - 1)
					if(i >= me.cursorX)
						break i
					end if
					do x :+ me.charWidth(me.src.src[me.cursorY][i], x)
				end for
				if(me.pageX > x)
					do me.pageX :: x
					do paint :: true
				end if
				if(me.pageX < x - scrWidth / @cellWidth + paddingX + 1)
					do me.pageX :: x - scrWidth / @cellWidth + paddingX + 1
					do paint :: true
				end if
			end block
			do @scrollXSrc.setState(0, maxX - 1 + paddingX, scrWidth / @cellWidth, me.pageX)
			if(paint)
				do @drawEditor.paint()
			end if
		end if

		block
			var x: int :: 0
			var str: []char :: me.src.src[me.cursorY]
			for i(0, me.cursorX - 1)
				do x :+ me.charWidth(str[i], x)
			end for
			do x :: me.lineNumberWidth + (x - me.pageX) * @cellWidth
			var y: int :: (me.cursorY - me.pageY) * @cellHeight
			if(x + 2 <= 0 | scrWidth - 17 <= x | y + @cellHeight <= 0 | scrHeight - 17 <= y)
				do @drawEditor.moveCaret(-1, -1)
			else
				do @drawEditor.moveCaret(x, y)
			end if
		end block

		do @setDirtyHint()

		func log10(n: int): int
			var result: int :: 0
			var m: int :: 1
			while(n >= m)
				do m :* 10
				do result :+ 1
			end while
			ret result
		end func
	end func

	func getAbsoluteX(): int
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret 0
		end if
		var absoluteX: int :: 0
		for i(0, me.cursorX - 1)
			if(i >= ^me.src.src[me.cursorY])
				break i
			end if
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], absoluteX)
			do absoluteX :+ charWidth2
		end for
		ret absoluteX
	end func

	func setAbsoluteX(absoluteX: int)
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret
		end if
		var x: int :: 0
		do me.cursorX :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(x + charWidth2 > absoluteX)
				break i
			end if
			do x :+ charWidth2
			do me.cursorX :+ 1
		end for
	end func

	func copyAreaStr()
		assert me.areaSelected()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		var str: []char
		if(y1 = y2)
			do str :: me.src.src[y1].sub(x1, x2 - x1)
		else
			do str :: me.src.src[y1].sub(x1, -1) ~ "\n"
			for i(y1 + 1, y2 - 1)
				do str :~ me.src.src[i] ~ "\n"
			end for
			do str :~ me.src.src[y2].sub(0, x2)
		end if
		do wnd@setClipboardStr(str)
	end func

	func delAreaStr()
		assert me.areaSelected()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		var len: int
		if(y1 = y2)
			do len :: x2 - x1
		else
			do len :: ^me.src.src[y1] - x1 + 1
			for i(y1 + 1, y2 - 1)
				do len :+ ^me.src.src[i] + 1
			end for
			do len :+ x2
		end if
		do me.cursorX :: x1
		do me.cursorY :: y1
		do me.del(me.cursorX, me.cursorY, len, true)
		do me.areaX :: -1
	end func

	func indentAreaStr()
		assert me.areaSelected()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		if(x2 = 0)
			do y2 :- 1
		end if
		do me.undo.recordBegin()
		for i(y1, y2)
			if(^me.src.src[i] <> 0)
				if(i = oldAreaY)
					do oldAreaX :+ 1
				end if
				if(i = oldCursorY)
					do oldCursorX :+ 1
				end if
				do me.ins(0, i, "\t", true)
			end if
		end for
		do me.undo.recordEnd()
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func

	func unindentAreaStr()
		assert me.areaSelected()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			do x1 :$ x2
			do y1 :$ y2
		end if
		if(x2 = 0)
			do y2 :- 1
		end if
		do me.undo.recordBegin()
		for i(y1, y2)
			if(^me.src.src[i] > 0 & me.src.src[i][0] = '\t')
				if(i = oldAreaY & oldAreaX > 0 & me.src.src[i][oldAreaX] <> '\t')
					do oldAreaX :- 1
				end if
				if(i = oldCursorY & oldCursorX > 0 & me.src.src[i][oldCursorX] <> '\t')
					do oldCursorX :- 1
				end if
				do me.del(0, i, 1, true)
			end if
		end for
		do me.undo.recordEnd()
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func

	func ins(x: int, y: int, str: []char, recordUndo: bool)
		var redo: UndoSrcIns
		if(recordUndo)
			do redo :: #UndoSrcIns
			do redo.document :: me
			do redo.x :: x
			do redo.y :: y
			do redo.str :: str
		end if
		for i(0, ^str - 1)
			if(str[i] = '\n')
				var line: []char :: me.src.src[y].sub(x, -1)
				do me.src.src[y] :: me.src.src[y].sub(0, x)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do me.src.src :: me.src.src.sub(0, y + 1) ~ [line] ~ me.src.src.sub(y + 1, -1)
				do me.src.color :: me.src.color.sub(0, y + 1) ~ [#[^line]bit8] ~ me.src.color.sub(y + 1, -1)
				do x :: 0
				do y :+ 1
			else
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ str[i].toStr() ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do x :+ 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcBsDel :: #UndoSrcBsDel
			do undo.document :: me
			do undo.kind :: 0
			do undo.x :: x
			do undo.y :: y
			do undo.len :: ^str
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	func bs(x: int, y: int, len: int, recordUndo: bool)
		var redo: UndoSrcBsDel
		if(recordUndo)
			do redo :: #UndoSrcBsDel
			do redo.document :: me
			do redo.kind :: 0
			do redo.x :: x
			do redo.y :: y
			do redo.len :: len
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = 0)
				if(y <> 0)
					do undoStr :: "\n" ~ undoStr
					var x2: int :: ^me.src.src[y - 1]
					do me.src.src[y - 1] :~ me.src.src[y]
					do me.src.color[y - 1] :: #[^me.src.src[y - 1]]bit8
					do me.src.src :: me.src.src.sub(0, y) ~ me.src.src.sub(y + 1, -1)
					do me.src.color :: me.src.color.sub(0, y) ~ me.src.color.sub(y + 1, -1)
					do y :- 1
					do x :: x2
				end if
			else
				do undoStr :: me.src.src[y][x - 1].toStr() ~ undoStr
				do me.src.src[y] :: me.src.src[y].sub(0, x - 1) ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
				do x :- 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcIns :: #UndoSrcIns
			do undo.document :: me
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	func del(x: int, y: int, len: int, recordUndo: bool)
		var redo: UndoSrcBsDel
		if(recordUndo)
			do redo :: #UndoSrcBsDel
			do redo.document :: me
			do redo.kind :: 1
			do redo.x :: x
			do redo.y :: y
			do redo.len :: len
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = ^me.src.src[y])
				if(y <> ^me.src.src - 1)
					do undoStr :~ "\n"
					do me.src.src[y] :~ me.src.src[y + 1]
					do me.src.color[y] :: #[^me.src.src[y]]bit8
					do me.src.src :: me.src.src.sub(0, y + 1) ~ me.src.src.sub(y + 2, -1)
					do me.src.color :: me.src.color.sub(0, y + 1) ~ me.src.color.sub(y + 2, -1)
				end if
			else
				do undoStr :~ me.src.src[y][x].toStr()
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ me.src.src[y].sub(x + 1, -1)
				do me.src.color[y] :: #[^me.src.src[y]]bit8
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcIns :: #UndoSrcIns
			do undo.document :: me
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do @setDirtyInterpret()
		do me.changed :: true
	end func

	func getFuncHint(srcName: []char, x: int, y: int)
		var charColor: bit8 :: me.src.color[y][x]
		if(x > 0)
			do x :- 1
		end if
		switch(charColor $ @CharColor)
		case %char_, %str, %lineComment, %comment
			while(x > 0 & me.src.color[y][x].and(16#7Fb8) = charColor)
				do x :- 1
			end while
		end switch
		var parenthesisNum: int :: 0
		var commaNum: int :: 0
		while(x > 0)
			switch(me.src.src[y][x])
			case '('
				do parenthesisNum :- 1
				if(parenthesisNum < 0)
					while(x > 0 & (me.src.src[y][x - 1] = ' ' | me.src.src[y][x - 1] = '\t'))
						do x :- 1
					end while
					if(x > 0)
						switch color(me.src.color[y][x - 1].and(16#7Fb8) $ @CharColor)
						case %identifier, %global, %reserved
							do x :- 1
							var last: int :: x
							while(x > 0 & me.src.color[y][x - 1].and(16#7Fb8) = color $ bit8)
								do x :- 1
							end while
							var last2: int :: last
							while(last2 < ^me.src.color[me.cursorY] - 1 & me.src.color[me.cursorY][last2 + 1].and(16#7Fb8) = color $ bit8)
								do last2 :+ 1
							end while
							var word: []char :: me.src.src[y].sub(x, last2 - x).trim()
							var hint: []char :: @getHint2(srcName, y + 1, last, word)
							if(hint =& null)
								do hint :: ""
							end if
							if(@textFunc <> hint)
								do @textFunc :: hint
								do @updateLog()
							end if
							ret
						default
							do parenthesisNum :: 0
							do commaNum :: 0
						end switch
					end if
				end if
			case ')'
				do parenthesisNum :+ 1
			case ','
				if(parenthesisNum = 0)
					do commaNum :+ 1
				end if
			default
				switch color(me.src.color[y][x].and(16#7Fb8) $ @CharColor)
				case %char_, %str, %lineComment, %comment
					while(x > 0 & me.src.color[y][x - 1].and(16#7Fb8) = color $ bit8)
						do x :- 1
					end while
				end switch
			end switch
			do x :- 1
		end while
		if(@textFunc <> "")
			do @textFunc :: ""
			do @updateLog()
		end if
	end func

	func scrollPageX(wheel: int)
		do me.pageX :+ wheel
		; TODO: me.pageX >= ?
		if(me.pageX < 0)
			do me.pageX :: 0
		end if
		do me.refreshCursor(false, false)
		do @scrollXSrc.setPos(me.pageX)
		do @drawEditor.paint()
	end func

	func scrollPageY(wheel: int)
		do me.pageY :+ wheel
		const paddingY: int :: 17 / @cellHeight + 1
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		if (me.pageY >= ^me.src.src - scrHeight / @cellHeight + paddingY)
			do me.pageY :: ^me.src.src - scrHeight / @cellHeight + paddingY
		end if
		if (me.pageY < 0)
			do me.pageY :: 0
		end if
		do me.refreshCursor(false, false)
		do @scrollYSrc.setPos(me.pageY)
		do @drawEditor.paint()
	end func
end class

class DocumentArBase(@Document)
	+*func init(src: [][]char)
		do me.initVars()
		do me.obj2dRoot :: #@Obj2dRoot
		do me.obj2dRoot.init("", 0, 0, 1600, 900)
		do me.pageX :: 0
		do me.pageY :: 0
		do me.mode :: %none
		do me.hold :: null

		if(src <>& null)
			assert src[0].sub(0, 6) = ";;[ar_"
			var ptr: int :: 6
			while(src[0][ptr] <> ']')
				do ptr :+ 1
			end while
			do ptr :+ 1
			do me.initFromMeta(src[0], &ptr)
		end if
	end func

	+*func getSrc(): [][]char
		var meta: []char :: ";;[ar_" ~ me.getMeta() ~ "]" ~ getMetaRecursion(me.obj2dRoot)
		do me.src :: [meta] ~ getSrcRecursion(me.obj2dRoot)
		ret me.src

		func getMetaRecursion(obj: @Obj2d): []char
			var meta: []char :: obj.writeMeta()
			do obj.children.head()
			while(!obj.children.term())
				do meta :~ getMetaRecursion(obj.children.get())
				do obj.children.next()
			end while
			ret meta
		end func

		func getSrcRecursion(obj: @Obj2d): [][]char
			var src: [][]char :: obj.getSrc()
			do obj.children.head()
			while(!obj.children.term())
				do src :~ getSrcRecursion(obj.children.get())
				do obj.children.next()
			end while
			ret src
		end func
	end func

	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, @colorBack)
		do drawRecursion(me.obj2dRoot, me.pageX, me.pageY, me.hold)

		func drawRecursion(obj: @Obj2d, pageX: int, pageY: int, hold: @Obj2d)
			do draw@rect((obj.x - 2 - pageX) $ float, (obj.y - 2 - pageY) $ float, (obj.width + 4) $ float, (obj.height + 4) $ float, hold =& obj ?(16#FF6666FF, 16#FF666666))
			do obj.draw(pageX, pageY)
			do obj.children.head()
			while(!obj.children.term())
				do drawRecursion(obj.children.get(), pageX, pageY, hold)
				do obj.children.next()
			end while
		end func
	end func

	+*func mouseDownL(x: int, y: int)
		var sel: int :: @listInfo.getSel()
		if(sel <= 0)
			do me.mode :: %move
			do me.hold :: selRecursion(me.obj2dRoot, x + me.pageX, y + me.pageY)
			if(me.hold =& null)
				do me.hold :: me.obj2dRoot
			end if
		else
			if (@lockingEditor)
				do @showMsgRunning()
				ret
			end if
			var name: []char :: @listInfo.getText(sel)
			do me.mode :: %put
			var obj: @Obj2d :: me.makeObj2d(name)
			do obj.init(me.getDefaultName(name), x, y, minSize, minSize)
			if(me.hold =& null)
				do me.obj2dRoot.children.add(obj)
			else
				do me.hold.children.add(obj)
			end if
			do me.hold :: obj
			do me.changed :: true
		end if
		do @drawEditor.paint()

		func selRecursion(obj: @Obj2d, x: int, y: int): @Obj2d
			do obj.children.head()
			while(!obj.children.term())
				var result: @Obj2d :: selRecursion(obj.children.get(), x, y)
				if(result <>& null)
					ret result
				end if
				do obj.children.next()
			end while
			if(obj.x <= x & x <= obj.x + obj.width & obj.y <= y & y <= obj.y + obj.height)
				ret obj
			end if
			ret null
		end func
	end func

	+*func mouseUpL(x: int, y: int)
		switch(me.mode)
		case %put
			if (@lockingEditor)
				do @showMsgRunning()
				ret
			end if
			do me.moveObj2d(x, y)
			do me.mode :: %none
			do @drawEditor.paint()
		end switch
	end func

	+*func mouseMove(x: int, y: int)
		switch(me.mode)
		case %put
			if (@lockingEditor)
				do @showMsgRunning()
				ret
			end if
			do me.moveObj2d(x, y)
			do @drawEditor.paint()
		end switch
	end func

	+*func focus(isFocus: bool)
		if(isFocus)
			do me.refreshScroll()
		end if
	end func

	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		; TODO:
	end func

	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		; TODO:
	end func

	+*func keyChar(key: char)
		; TODO:
	end func

	+*func scrollX(pos: int)
		do me.pageX :: pos
		do @drawEditor.paint()
	end func

	+*func scrollY(pos: int)
		do me.pageY :: pos
		do @drawEditor.paint()
	end func

	+*func wheelX(wheel: int)
		; TODO:
	end func

	+*func wheelY(wheel: int)
		; TODO:
	end func

	+*func cmdUndo()
		; TODO:
	end func

	+*func cmdRedo()
		; TODO:
	end func

	+*func cmdCut()
		; TODO:
	end func

	+*func cmdCopy()
		; TODO:
	end func

	+*func cmdPaste()
		; TODO:
	end func

	+*func cmdDel()
		; TODO:
	end func

	+*func cmdSelAll()
		; TODO:
	end func

	+*func findPrev(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		ret false
	end func

	+*func findNext(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		ret false
	end func

	+*func replaceOne(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	end func

	+*func replaceAll(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): int
	end func

	+*func undoImpl(undo2: @UndoCmd)
		; TODO:
	end func

	const padding: int :: 32
	const minSize: int :: 50

	enum Mode
		none
		put
		move
	end enum

	var src: [][]char
	var obj2dRoot: @Obj2dRoot
	var pageX: int
	var pageY: int
	var mode: Mode
	var hold: @Obj2d

	func initFromMeta(src2: []char, ptr: &int)
	end func

	func getMeta(): []char
	end func

	func refreshScroll()
		var scrWidth: int
		var scrHeight: int
		do @drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		do @scrollXSrc.setState(me.obj2dRoot.x, me.obj2dRoot.width + padding, scrWidth, me.pageX)
		do @scrollYSrc.setState(me.obj2dRoot.y, me.obj2dRoot.height + padding, scrHeight, me.pageY)
	end func

	func makeObj2d(name: []char): @Obj2d
	end func

	func getDefaultName(name: []char): []char
		var num: int :: 1
		var newName: []char
		while loop(true)
			do newName :: name ~ num.toStr()
			if(!searchRecursion(newName, me.obj2dRoot))
				break loop
			end if
			do num :+ 1
		end while
		ret newName

		func searchRecursion(name: []char, obj: @Obj2d): bool
			if(name = obj.name)
				ret true
			end if
			do obj.children.head()
			while(!obj.children.term())
				if(searchRecursion(name, obj.children.get()))
					ret true
				end if
				do obj.children.next()
			end while
			ret false
		end func
	end func

	func moveObj2d(x: int, y: int)
		var width: int :: x - me.hold.x
		var height: int :: y - me.hold.y
		if(width < minSize)
			do width :: minSize
		end if
		if(height < minSize)
			do height :: minSize
		end if
		do me.hold.width :: width
		do me.hold.height :: height
	end func
end class

class Obj2d()
	+func init(name: []char, x: int, y: int, width: int, height: int)
		do me.children :: #list<Obj2d>
		do me.name :: name
		do me.x :: x
		do me.y :: y
		do me.width :: width
		do me.height :: height
	end func

	+func draw(pageX: int, pageY: int)
	end func

	+func getSrc(): [][]char
	end func

	+func readMeta(src: []char, ptr: &int)
	end func

	+func writeMeta(): []char
	end func

	+var children: list<Obj2d>
	+var name: []char
	+var x: int
	+var y: int
	+var width: int
	+var height: int

	func readMetaBase(src: []char, ptr: &int)
		var x2: int
		do @arBaseParseWord(src, &ptr).toInt(&x2)
		var y2: int
		do @arBaseParseWord(src, &ptr).toInt(&y2)
		var width2: int
		do @arBaseParseWord(src, &ptr).toInt(&width2)
		var height2: int
		do @arBaseParseWord(src, &ptr).toInt(&height2)
		do me.init(@arBaseParseWord(src, &ptr), x2, y2, width2, height2)
	end func

	func writeMetaBase(type: []char): []char
		ret ",\{type},\{me.name},\{me.x.toStr()},\{me.y.toStr()},\{me.width.toStr()},\{me.height.toStr()},\{(^me.children).toStr()}"
	end func
end class

class Obj2dRoot(@Obj2d)
	+*func draw(pageX: int, pageY: int)
		do draw@rect((me.x - pageX) $ float, (me.y - pageY) $ float, me.width $ float, me.height $ float, me.color)
	end func

	+*func getSrc(): [][]char
		ret [""]
	end func

	+*func writeMeta(): []char
		ret (^me.children).toStr()
	end func

	+var color: int
end class

class DocumentArWnd(@DocumentArBase)
	*func initFromMeta(src2: []char, ptr: &int)
		do me.obj2dRoot.color :: draw@white
		do me.initFromMetaRecursion(me.obj2dRoot, src2, &ptr)
	end func

	*func getMeta(): []char
		ret "wnd"
	end func

	*func makeObj2d(name: []char): @Obj2d
		switch(name)
		case "Button"
			ret #Obj2dBtn
		end switch
		assert(false)
	end func

	class Obj2dBtn(@Obj2d)
		+*func draw(pageX: int, pageY: int)
			do draw@rect((me.x - pageX) $ float, (me.y - pageY) $ float, me.width $ float, me.height $ float, 16#FF808080)
		end func

		+*func getSrc(): [][]char
			ret [""]
			; TODO:
		end func

		+*func readMeta(src: []char, ptr: &int)
			do me.readMetaBase(src, &ptr)
		end func

		+*func writeMeta(): []char
			ret me.writeMetaBase("btn")
		end func
	end class

	func initFromMetaRecursion(parent: @Obj2d, src: []char, ptr: &int)
		var num: int
		do @arBaseParseWord(src, &ptr).toInt(&num)
		for i(0, num - 1)
			var obj: @Obj2d
			switch(@arBaseParseWord(src, &ptr))
			case "btn"
				do obj :: #Obj2dBtn
			default
				ret
			end switch
			do obj.readMeta(src, &ptr)
			do parent.children.add(obj)
			do me.initFromMetaRecursion(obj, src, &ptr)
		end for
	end func
end class

class DocumentArDraw(@DocumentArDraw)
	*func initFromMeta(src2: []char, ptr: &int)
		do me.obj2dRoot.color :: draw@white
		; TODO:
	end func

	*func getMeta(): []char
		ret "draw"
	end func

	*func makeObj2d(name: []char): @Obj2d
	end func
end class

const fontSize: int :: 11
const cellWidth: int :: 9
const cellHeight: int :: 18
const langEn: bool :: false
const colorBack: int :: 16#FFFFF5F5
const untitledSrcName: []char :: "_untitled_.kn"
const untitledInternalName: []char :: "\\_untitled_"

enum CharColor
	none
	identifier
	global
	reserved
	number
	str
	char_
	lineComment
	comment
	symbol
	max
end enum

var title: []char
var mainSrcName: []char
var mainSrcDir: []char
var sysDir: []char
var srcCharColor: []int
var font: draw@Font
var documents: dict<[]char, @Document>
var curDocument: @Document
var runningFiles: list<[]char>
var drag: bool
var dirtyInterpret: int
var dirtyInterpretTime: int
var dirtyHint: bool
var dirtyHintTime: int
var blankMem: int
var listInfoItem: list<@ListInfoItem>
var auxiliaryErr: dict<@Pos, []char>
var lockingEditor: bool
var textErr: []char
var textHint: []char
var textFunc: []char
var textLog: []char

func main()
	block
		var major: int
		var minor: int
		var micro: int
		do @version(&major, &minor, &micro)
		do @title :: "Kuin Programming Language \{major}.\{minor}.\{micro}"
	end block
	do @runningFiles :: #list<[]char>
	do @wndFindEditPatternLast :: ""
	do @wndFindEditReplaceLast :: ""
	do @wndFindChkDistinguishCaseLast :: true

	do @initCompiler(2, @langEn ?(1, 0))
	do wnd@onKeyPress(@onKeyPress)
	do makeWnd()
	do initEditor()

	if(^lib@cmdLine() > 0)
		do @open(lib@cmdLine()[0].replace("\\", "/"))
	else
		do @new(null, null)
	end if

	do @drawEditor.onPaint :: @drawEditorOnPaint
	do @drawEditor.onMouseDownL :: @drawEditorOnMouseDownL
	do @drawEditor.onMouseUpL :: @drawEditorOnMouseUpL
	do @drawEditor.onMouseMove :: @drawEditorOnMouseMove
	do @drawEditor.onFocus :: @drawEditorOnFocus
	do @drawEditor.onKeyDown :: @drawEditorOnKeyDown
	do @drawEditor.onKeyUp :: @drawEditorOnKeyUp
	do @drawEditor.onKeyChar :: @drawEditorOnKeyChar
	do @drawEditor.onScrollX :: @drawEditorOnScrollX
	do @drawEditor.onScrollY :: @drawEditorOnScrollY
	do @drawEditor.onMouseWheelX :: @drawEditorOnMouseWheelX
	do @drawEditor.onMouseWheelY :: @drawEditorOnMouseWheelY
	do @wndMain.focus()
	do @drawEditor.focus()

	do mainLoop()

	func makeWnd()
		do @wndMain :: wnd@makeWnd(null, %normal, 1224, 768, @title)
		do @wndMain.minMax(930, 640, -1, -1)
		do @wndMain.onClose :: @wndMainOnClose
		do @wndMain.onActivate :: @wndMainOnActivate
		do @wndMain.onPushMenu :: @wndMainOnPushMenu
		do @treeItem :: wnd@makeTree(@wndMain, 12, 12, 244, 466, %fix, %fix)
		do @listInfo :: wnd@makeList(@wndMain, 12, 484, 244, 272, %fix, %scale)
		do @listInfo.onSel :: @listInfoOnSel
		do @editFile :: wnd@makeEdit(@wndMain, 262, 12, 759, 15, %scale, %fix)
		do @editFile.readonly(true)
		do @drawEditor :: wnd@makeDraw(@wndMain, 262, 33, 759, 582, %scale, %scale, true)
		do @scrollXSrc :: wnd@makeScrollX(@drawEditor, 0, 565, 742, 17, %scale, %move)
		do @scrollXSrc.setState(0, 0, 1, 0)
		do @scrollYSrc :: wnd@makeScrollY(@drawEditor, 742, 0, 17, 565, %move, %scale)
		do @scrollYSrc.setState(0, 0, 1, 0)
		do @editHint :: wnd@makeEditMulti(@wndMain, 262, 621, 391, 135, %scale, %move)
		do @editHint.readonly(true)
		do @editLog :: wnd@makeEditMulti(@wndMain, 659, 621, 553, 135, %move, %move)
		do @editLog.readonly(true)
		do @btnCompile :: wnd@makeBtn(@wndMain, 1027, 12, 185, 23, %move, %fix, @langEn ?("Compile && Run", "コンパイル＆実行"))
		do @btnCompile.onPush :: @btnCompileOnPush
		do @groupEnv :: wnd@makeGroup(@wndMain, 1027, 41, 185, 62, %move, %fix, @langEn ?("Environment", "実行環境"))
		do @radioEnvWnd :: wnd@makeRadio(@groupEnv, 6, 18, 173, 16, %fix, %fix, @langEn ?("Window", "ウインドウ"))
		do @radioEnvWnd.setChk(true)
		do @radioEnvCui :: wnd@makeRadio(@groupEnv, 6, 40, 173, 16, %fix, %fix, @langEn ?("CUI", "CUI"))
		do @btnRls :: wnd@makeBtn(@wndMain, 1027, 109, 185, 23, %move, %fix, @langEn ?("Release Build...", "リリースビルド"))
		do @btnRls.onPush :: @btnRlsOnPush
		do @listFile :: wnd@makeList(@wndMain, 1027, 255, 185, 360, %move, %scale)
		do @listFile.onSel :: @listFileOnSel
		do @menuMain :: wnd@makeMenu()
		do @popupMainFile :: wnd@makePopup()
		do @popupMainFile.add(16#0001, @langEn ?("&New\tCtrl+N", "新規作成(&N)\tCtrl+N"))
		do @popupMainFile.add(16#0002, @langEn ?("&Load...\tCtrl+O", "開く(&O)\tCtrl+O"))
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0003, @langEn ?("&Save All\tCtrl+S", "すべて保存(&S)\tCtrl+S"))
		do @popupMainFile.add(16#0004, @langEn ?("Save &As...\tCtrl+Shift+S", "名前を付けて保存(&A)\tCtrl+Shift+S"))
		do @popupMainFile.addLine()
		do @popupMainFile.add(16#0005, @langEn ?("E&xit\tCtrl+Q", "終了(&E)\tCtrl+Q"))
		do @menuMain.addPopup(@langEn ?("&File", "ファイル(&F)"), @popupMainFile)
		do @popupMainEdit :: wnd@makePopup()
		do @popupMainEdit.add(16#0030, @langEn ?("Add Ne&w File\tCtrl+Shift+A", "新しいファイルを追加(&W)\tCtrl+Shift+A"))
		do @popupMainEdit.add(16#0031, @langEn ?("Add Existin&g File", "既存のファイルを追加(&G)"))
		do @popupMainEdit.addLine()
		do @popupMainEdit.add(16#0032, @langEn ?("&Undo\tCtrl+Z", "元に戻す(&U)\tCtrl+Z"))
		do @popupMainEdit.add(16#0033, @langEn ?("&Redo\tCtrl+Shift+Z, Ctrl+Y", "やり直し(&R)\tCtrl+Shift+Z, Ctrl+Y"))
		do @popupMainEdit.addLine()
		do @popupMainEdit.add(16#0034, @langEn ?("Cu&t\tCtrl+X", "切り取り(&T)\tCtrl+X"))
		do @popupMainEdit.add(16#0035, @langEn ?("&Copy\tCtrl+C", "コピー(&C)\tCtrl+C"))
		do @popupMainEdit.add(16#0036, @langEn ?("&Paste\tCtrl+V", "貼り付け(&P)\tCtrl+V"))
		do @popupMainEdit.add(16#0037, @langEn ?("&Delete\tDel", "削除(&D)\tDel"))
		do @popupMainEdit.add(16#0038, @langEn ?("Select &All\tCtrl+A", "すべて選択(&A)\tCtrl+A"))
		do @popupMainEdit.addLine()
		do @popupMainEdit.add(16#0039, @langEn ?("&Find\tCtrl+F", "検索(&F)\tCtrl+F"))
		do @popupMainEdit.add(16#003A, @langEn ?("&Replace\tCtrl+H", "置換(&R)\tCtrl+H"))
		do @menuMain.addPopup(@langEn ?("&Edit", "編集(&E)"), @popupMainEdit)
		do @popupMainBuild :: wnd@makePopup()
		do @popupMainBuild.add(16#0020, @langEn ?("&Compile && Run\tF5", "コンパイル＆実行(&C)\tF5"))
		do @popupMainBuild.addLine()
		do @popupMainBuild.add(16#0021, @langEn ?("&Release Build...\tCtrl+Shift+B", "リリースビルド(&R)\tCtrl+Shift+B"))
		do @menuMain.addPopup(@langEn ?("&Build", "ビルド(&B)"), @popupMainBuild)
		do @popupMainHelp :: wnd@makePopup()
		do @popupMainHelp.add(16#0010, @langEn ?("&View Help\tF1", "ヘルプの表示(&V)\tF1"))
		do @popupMainHelp.addLine()
		do @popupMainHelp.add(16#0011, @langEn ?("&About Kuin...", "Kuinについて(&A)..."))
		do @menuMain.addPopup(@langEn ?("&Help", "ヘルプ(&H)"), @popupMainHelp)
		do @wndMain.setMenu(@menuMain)
	end func

	func initEditor()
		do @sysDir :: file@exeDir() ~ "sys/"
		do @srcCharColor :: #[%max $ @CharColor $ int]int
		do @srcCharColor[%none $ @CharColor $ int] :: 16#FF999999
		do @srcCharColor[%identifier $ @CharColor $ int] :: 16#FF009BEA
		do @srcCharColor[%global $ @CharColor $ int] :: 16#FFCC00F6
		do @srcCharColor[%reserved $ @CharColor $ int] :: 16#FF1400F6
		do @srcCharColor[%number $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%str $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%char_ $ @CharColor $ int] :: 16#FFEA0062
		do @srcCharColor[%lineComment $ @CharColor $ int] :: 16#FF1EB000
		do @srcCharColor[%comment $ @CharColor $ int] :: 16#FF1EB000
		do @srcCharColor[%symbol $ @CharColor $ int] :: 16#FF666666
		do @font :: draw@makeFont("Consolas", @fontSize, false, false, false, @cellWidth $ float)
		do @drag :: false
		do @lockingEditor :: false
		do @textErr :: ""
		do @textHint :: ""
		do @textFunc :: ""
		do @textLog :: ""
	end func

	func mainLoop()
		while(wnd@act())
			if(@curDocument =$ @DocumentSrc)
				var document: @DocumentSrc :: @curDocument $ @DocumentSrc
				switch(@dirtyInterpret)
				case 0
					if(lib@sysTime() - @dirtyInterpretTime > 150)
						do @interpret1(document.src.src, document.src.color)
						do document.interpreted :: true
						do @drawEditor.paint()
						do @dirtyInterpret :: 1
					end if
				case 1
					if(lib@sysTime() - @dirtyInterpretTime > 1200)
						do @resetAuxiliary()
						try
							if(@interpret2(@mainSrcName, @getSrc, null, @getEnv(), @logForInterpret, @langEn ?(1, 0), @blankMem))
								do @blankMem :: 1 - @blankMem
							end if
						catch
						end try
						do @updateAuxiliary()
						do @updateUi()
						do @dirtyInterpret :: 2
					end if
				end switch
				if(@dirtyHint)
					if(lib@sysTime() - @dirtyHintTime > 100 & @dirtyInterpret >= 1)
						do document.showHint()
						do @dirtyHint :: false
					end if
				end if
			end if
		end while

		do @finCompiler()
	end func
end func

func onKeyPress(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
	if(@wndFind <>& null & @wndFind.focusedWnd())
		if(key = %esc)
			do @wndFind.close()
			ret true
		end if
		if(@tabOrderFind <>& null & @tabOrderFind.chk(key, shiftCtrl))
			ret true
		end if
	elif(@wndMain.focusedWnd())
		switch(shiftCtrl)
		case %none
			switch(key)
			case %del
				do @wndMainOnPushMenu(@wndMain, 16#0037)
				ret true
			case %f1
				do @wndMainOnPushMenu(@wndMain, 16#0010)
				ret true
			case %f5
				do @wndMainOnPushMenu(@wndMain, 16#0020)
				ret true
			end switch
		case %shift
			switch(key)
			end switch
		case %ctrl
			switch(key)
			case %a
				do @wndMainOnPushMenu(@wndMain, 16#0038)
				ret true
			case %c
				do @wndMainOnPushMenu(@wndMain, 16#0035)
				ret true
			case %f
				do @wndMainOnPushMenu(@wndMain, 16#0039)
				ret true
			case %h
				do @wndMainOnPushMenu(@wndMain, 16#003A)
				ret true
			case %n
				do @wndMainOnPushMenu(@wndMain, 16#0001)
				ret true
			case %o
				do @wndMainOnPushMenu(@wndMain, 16#0002)
				ret true
			case %s
				do @wndMainOnPushMenu(@wndMain, 16#0003)
				ret true
			case %q
				do @wndMainOnPushMenu(@wndMain, 16#0005)
				ret true
			case %v
				do @wndMainOnPushMenu(@wndMain, 16#0036)
				ret true
			case %x
				do @wndMainOnPushMenu(@wndMain, 16#0034)
				ret true
			case %y
				do @wndMainOnPushMenu(@wndMain, 16#0033)
				ret true
			case %z
				do @wndMainOnPushMenu(@wndMain, 16#0032)
				ret true
			end switch
		case (%shift $ wnd@ShiftCtrl).or(%ctrl)
			switch(key)
			case %a
				do @wndMainOnPushMenu(@wndMain, 16#0030)
			case %b
				do @wndMainOnPushMenu(@wndMain, 16#0021)
				ret true
			case %s
				do @wndMainOnPushMenu(@wndMain, 16#0004)
				ret true
			case %z
				do @wndMainOnPushMenu(@wndMain, 16#0033)
				ret true
			end switch
		end switch
	end if
	ret false
end func

func open(file: []char)
	var src: list<[]char> :: #list<[]char>
	var filePtr: file@Reader :: file@makeReader(file)
	if(filePtr =& null)
		var msg: []char
		if(@langEn)
			do msg :: "Loading failed. " ~ file
		else
			do msg :: "読み込みに失敗しました。 " ~ file
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end if
	while(!filePtr.term())
		do src.add(filePtr.readLine())
	end while
	do filePtr.fin()
	do @new(file, src.toArray())
end func

func new(srcName: []char, src: [][]char)
	do @documents :: #dict<[]char, @Document>
	do @curDocument :: #@DocumentSrc
	do @curDocument.init(src)
	do @mainSrcName :: srcName =& null ?(@untitledSrcName, srcName)
	do @mainSrcDir :: srcName =& null ?("", file@dir(srcName))
	do @documents.add(@mainSrcName, @curDocument)
	do @setDirtyInterpret()
	do @setDirtyHint()
	do @blankMem :: 0
	do @resetAuxiliary()
	do @updateUi()
	do @resetHint()
	do @drawEditor.paint()
	do @drawEditor.focus()
end func

func save(): bool
	var file: []char :: wnd@saveFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0, "kn")
	if(file =& null)
		ret false
	end if
	if(!@saveSrc(file, @curDocument.getSrc()))
		ret false
	end if
	do @mainSrcName :: file
	do @mainSrcDir :: file@dir(file)
	var newDocuments: dict<[]char, @Document> :: #dict<[]char, @Document>
	var data: @DocumentsClass :: #@DocumentsClass
	do data.documents :: newDocuments
	do @documents.forEach(callback, data)
	do newDocuments.add(file, @curDocument)
	do @documents :: newDocuments
	do @curDocument.changed :: false
	do @updateUi()
	ret true

	func callback(src: []char, document: @Document, data: @DocumentsClass): bool
		if(document <>& @curDocument)
			do data.documents.add(src, document)
		end if
		ret true
	end func
end func

func saveAll(): bool
	if(@mainSrcName = @untitledSrcName)
		if(!@save())
			ret false
		end if
	end if
	do @saveAllSuccess :: true
	do @documents.forEach(callback, null)
	do @updateUi()
	ret @saveAllSuccess

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		if(document.changed)
			if(@saveSrc(src, document.getSrc()))
				do document.changed :: false
			else
				do @saveAllSuccess :: false
			end if
		end if
		ret true
	end func
end func
var saveAllSuccess: bool

func saveSrc(path: []char, src: [][]char): bool
	var filePtr: file@Writer :: file@makeWriter(path, false)
	if(filePtr =& null)
		var msg: []char
		if(@langEn)
			do msg :: "Saving failed. " ~ path
		else
			do msg :: "保存に失敗しました。 " ~ path
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret false
	end if
	for line(0, ^src - 1)
		do filePtr.writeStr(src[line])
		if(line <> ^src - 1 | src[line] <> "")
			do filePtr.writeChar('\n')
		end if
	end for
	do filePtr.fin()
	ret true
end func

func add(file: []char): @Document
	if(!(^@sysDir <= ^file & @sysDir = file.sub(0, ^@sysDir) | @mainSrcDir <> "" & ^@mainSrcDir <= ^file & @mainSrcDir = file.sub(0, ^@mainSrcDir)))
		ret null
	end if

	var src: list<[]char> :: #list<[]char>
	var filePtr: file@Reader :: file@makeReader(file)
	if(filePtr =& null)
		ret null
	end if

	var document: @Document :: null
	var first: bool :: true
	while loop(!filePtr.term())
		var line: []char :: filePtr.readLine()
		do src.add(line)
		if(first)
			do first :: false
			if(^line >= 3 & line.sub(0, 3) = ";;[")
				var ptr: int :: 6
				while(ptr < ^line & line[ptr] <> ']')
					do ptr :+ 1
				end while
				switch(line.sub(3, ptr - 3))
				case "ar_wnd"
					do document :: #@DocumentArWnd
				end switch
				break loop
			end if
		end if
	end while
	do filePtr.fin()
	if(document =& null)
		do document :: #@DocumentSrc
	end if
	do document.init(src.toArray())
	do @documents.add(file, document)
	ret document
end func

func setCurSrc(document: @Document)
	do @curDocument :: document
	if(document =$ @DocumentSrc)
		var document2: @DocumentSrc :: document $ @DocumentSrc
		if(!document2.interpreted)
			do @interpret1(document2.src.src, document2.src.color)
			do document2.interpreted :: true
		end if
	end if
	do @drawEditor.paint()
	do @drawEditor.focus()
end func

func chkChanged(): bool
	do @chkCloseChanged :: false
	do @documents.forEach(callback, null)
	if(!@chkCloseChanged)
		ret true
	end if
	var msg: []char
	if(@langEn)
		do msg :: "Do you want to save changes to the documents?"
	else
		do msg :: "ドキュメントへの変更を保存しますか？"
	end if
	var result: wnd@MsgBoxResult :: wnd@msgBox(@wndMain, msg, @title, %warn, %yesNoCancel)
	if(result = %cancel)
		ret false
	elif(result = %no)
		ret true
	end if
	ret @saveAll()

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		if(document.changed)
			do @chkCloseChanged :: true
			ret false
		end if
		ret true
	end func
end func
var chkCloseChanged: bool

func wndMainOnClose(wnd: wnd@WndBase): bool
	if(@lockingEditor)
		do @showMsgRunning()
		ret false
	end if
	if(@chkChanged())
		do @delRunningFiles()
		var dir: []char :: file@sysDir(%appData) ~ "Kuin/"
		try
			do file@delDir(dir)
		catch
		end try
		ret true
	end if
	ret false
end func

func wndMainOnActivate(wnd: wnd@WndBase, active: bool, minimized: bool)
	if(active & !minimized & @drawEditor <>& null)
		do @drawEditor.focus()
	end if
end func

func wndMainOnPushMenu(wnd: wnd@WndBase, id: int)
	switch(id)
	case 16#0001
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if (@chkChanged())
			do @new(null, null)
		end if
	case 16#0002
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		if (@chkChanged())
			var file: []char :: wnd@openFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0)
			if(file <>& null)
				do @open(file)
			end if
		end if
	case 16#0003
		do @saveAll()
	case 16#0004
		do @save()
	case 16#0005
		do @wndMain.close()
	case 16#0010
		do task@open("http://kuina.ch/kuin")
	case 16#0011
		block
			var major: int
			var minor: int
			var micro: int
			do @version(&major, &minor, &micro)
			do wnd@msgBox(@wndMain, "Kuin Programming Language\nVersion \{major}.\{minor}.\{micro}\n(C)Kuina-chan", @title, %info, %ok)
		end block
	case 16#0020
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		do @btnCompileOnPush(@btnCompile)
	case 16#0021
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		do @btnRlsOnPush(@btnRls)
	case 16#0030
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		do @addNewFile()
	case 16#0031
		if(@lockingEditor)
			do @showMsgRunning()
			ret
		end if
		do @addExistingFile()
	case 16#0032
		do @curDocument.cmdUndo()
	case 16#0033
		do @curDocument.cmdRedo()
	case 16#0034
		do @curDocument.cmdCut()
	case 16#0035
		do @curDocument.cmdCopy()
	case 16#0036
		do @curDocument.cmdPaste()
	case 16#0037
		do @curDocument.cmdDel()
	case 16#0038
		do @curDocument.cmdSelAll()
	case 16#0039
		do @showFind(false)
	case 16#003A
		do @showFind(true)
	end switch
end func

func listInfoOnSel(wnd: wnd@WndBase)
	if(@curDocument =$ @DocumentSrc)
		var sel: int :: @listInfo.getSel()
		if(sel <> -1 & sel < ^@listInfoItem)
			do @listInfoItem.head()
			var item: @ListInfoItem :: @listInfoItem.getOffset(sel)
			if(item.pos.src = @srcNameToInternalName(@mainSrcName))
				do (@curDocument $ @DocumentSrc).move(item.pos.col - 1, item.pos.row - 1)
				do @drawEditor.paint()
				do @drawEditor.focus()
			end if
			do @textErr :: item.text
			do @updateLog()
			do @dirtyHint :: false
		end if
	elif(@curDocument =$ @DocumentArBase)
	end if
end func

func drawEditorOnPaint(wnd: wnd@WndBase, width: int, height: int)
	do @curDocument.draw(width, height)
	do draw@render(0)
end func

func drawEditorOnMouseDownL(wnd: wnd@WndBase, x: int, y: int)
	do @drag :: true
	do @curDocument.mouseDownL(x, y)
end func

func drawEditorOnMouseUpL(wnd: wnd@WndBase, x: int, y: int)
	do @drag :: false
	do @curDocument.mouseUpL(x, y)
end func

func drawEditorOnMouseMove(wnd: wnd@WndBase, x: int, y: int)
	do @curDocument.mouseMove(x, y)
end func

func drawEditorOnFocus(wnd: wnd@WndBase, focus: bool)
	do @curDocument.focus(focus)
end func

func drawEditorOnKeyDown(wnd: wnd@WndBase, key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	do @curDocument.keyDown(key, shiftCtrl)
end func

func drawEditorOnKeyUp(wnd: wnd@WndBase, key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
	do @curDocument.keyUp(key, shiftCtrl)
end func

func drawEditorOnKeyChar(wnd: wnd@WndBase, key: char)
	do @curDocument.keyChar(key)
end func

func drawEditorOnScrollX(wnd: wnd@WndBase, pos: int)
	do @curDocument.scrollX(pos)
end func

func drawEditorOnScrollY(wnd: wnd@WndBase, pos: int)
	do @curDocument.scrollY(pos)
end func

func drawEditorOnMouseWheelX(wnd: wnd@WndBase, wheel: int)
	do @curDocument.wheelX(wheel)
end func

func drawEditorOnMouseWheelY(wnd: wnd@WndBase, wheel: int)
	do @curDocument.wheelY(wheel)
end func

func btnCompileOnPush(wnd: wnd@WndBase)
	if(@lockingEditor)
		do @showMsgRunning()
		ret
	end if
	do @lockEditor(true)
	var tmp: []char :: file@sysDir(%appData) ~ "Kuin/" ~ @addRunningFileName() ~ "/"
	var out: []char :: tmp ~ "out.exe"
	try
		do file@makeDir(tmp)
	catch
		var msg: []char
		if(@langEn)
			do msg :: "Could not delete. " ~ tmp
		else
			do msg :: "削除できませんでした。 " ~ tmp
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end try
	do @resetMemAllocator(@blankMem)
	do @textLog :: ""
	do @updateLog()
	var cmd: []char
	var cmdLine: []char
	if(@radioEnvWnd.getChk())
		do cmd :: out
		do cmdLine :: null
	elif(@radioEnvCui.getChk())
		do cmd :: file@sysDir(%system32) ~ "cmd.exe"
		do cmdLine :: "/C \"\"" ~ file@exeDir().replace("/", "\\") ~ "sys\\launcher.bat\" \"" ~ out.replace("/", "\\") ~ "\"\""
	end if
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, out, null, false, @getEnv(), @log, @langEn ?(1, 0)))
			if (@mainSrcName <> @untitledSrcName)
				var filePtr: file@Writer :: file@makeWriter(tmp ~ "_curdir_.txt", false)
				do filePtr.writeStr(file@dir(@mainSrcName))
				do filePtr.writeChar('\n')
				do filePtr.fin()
			end if
			do @textLog :~ @langEn ?("IK9999: Run.", "IK9999: 実行。\n")
			do @updateLog()
			if(@runDbg(cmd, cmdLine, idleFunc, eventFunc))
				do @textLog :~ @langEn ?("\nIK9999: Succees.\n", "\nIK9999: 正常終了。\n")
				do @updateLog()
			else
				do @textLog :~ @langEn ?("\nIK9999: Failure.\n", "\nIK9999: 実行失敗。\n")
				do @updateLog()
				do wnd@msgBox(@wndMain, @langEn ?("Could not run.", "実行できませんでした。"), @title, %err, %ok)
			end if
			do @delRunningFiles()
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, @langEn ?("Unexpected error.", "予期せぬエラーです。"), @title, %err, %ok)
	end try
	do @updateUi()
	do @lockEditor(false)

	func idleFunc()
		do wnd@act()
	end func

	func eventFunc(type: int, str: []char): int
		switch(type)
		case 0
			do @textLog :~ str.sub(5, -1)
			do @updateLog()
		end switch
	end func
end func

func btnRlsOnPush(wnd: wnd@WndBase)
	if(@lockingEditor)
		do @showMsgRunning()
		ret
	end if
	var file: []char :: wnd@saveFileDialog(@wndMain, [@langEn ?("Archive file (*.zip)", "アーカイブファイル (*.zip)"), "*.zip"], 0, "zip")
	if(file =& null)
		ret
	end if
	do @lockEditor(true)
	var fileName: []char :: file@delExt(file@fileName(file))
	var tmp: []char :: file@sysDir(%appData) ~ "Kuin/" ~ @addRunningFileName() ~ "/" ~ fileName ~ "/"
	var out: []char :: tmp ~ fileName ~ ".exe"
	try
		do file@makeDir(tmp)
	catch
		var msg: []char
		if(@langEn)
			do msg :: "Could not delete. " ~ tmp
		else
			do msg :: "削除できませんでした。 " ~ tmp
		end if
		do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
		ret
	end try
	do @resetMemAllocator(@blankMem)
	do @textLog :: ""
	do @updateLog()
	try
		do @resetAuxiliary()
		if(@build(@mainSrcName, @getSrc, null, out, null, true, @getEnv(), @log, @langEn ?(1, 0)))
			if(@mainSrcName <> @untitledSrcName)
				var resSrc: []char :: file@dir(@mainSrcName) ~ "res/"
				if(file@exist(resSrc))
					var resDst: []char :: tmp ~ "res/"
					do file@copyDir(resDst, resSrc)
				end if
			end if
			if(zip@zip(file, tmp, -1))
				do wnd@msgBox(@wndMain, @langEn ?("The build succeeded.", "ビルドが成功しました。"), @title, %info, %ok)
			else
				var msg: []char
				if(@langEn)
					do msg :: "Could not make the archive file. " ~ file
				else
					do msg :: "アーカイブファイルを作成できませんでした。 " ~ file
				end if
				do wnd@msgBox(@wndMain, msg, @title, %err, %ok)
				ret
			end if
			do @delRunningFiles()
		end if
		do @updateAuxiliary()
	catch
		do wnd@msgBox(@wndMain, @langEn ?("Unexpected error.", "予期せぬエラーです。"), @title, %err, %ok)
	end try
	do @updateUi()
	do @lockEditor(false)
end func

func listFileOnSel(wnd: wnd@WndBase)
	var sel: int :: @listFile.getSel()
	if(sel <> -1)
		var internalName: []char :: removePrefix(@listFile.getText(sel))
		if(^internalName > 0 & internalName[0] = '\\')
			var src: []char :: @internalNameToSrcName(internalName)
			var document: @Document :: @documents.get(src)
			if(document <>& null)
				do @setCurSrc(document)
			end if
		end if
	end if
	do @updateUi()

	func removePrefix(src: []char): []char
		var begin: int :: 0
		while loop(begin < ^src)
			switch(src[begin])
			case '*', '>'
				do begin :+ 1
			default
				break loop
			end switch
		end while
		if(begin = 0)
			ret src
		else
			ret src.sub(begin, -1)
		end if
	end func
end func

func getSrc(path: []char): [][]char
	var path2: []char :: (##path).replace("\\", "/")
	var document: @Document :: @documents.get(path2)
	if(document <>& null)
		ret document.getSrc()
	end if

	do document :: @add(path2)
	ret document =& null ?(null, document.getSrc())
end func

func getEnv(): []char
	if(@radioEnvWnd.getChk())
		ret "wnd"
	elif(@radioEnvCui.getChk())
		ret "cui"
	end if
	ret "wnd"
end func

func log(args: [][]char, row: int, col: int)
	var msg: []char :: @nullStr(args[0]) ~ ": " ~ @nullStr(args[1])
	if(args[2] =& null)
		do @textLog :~ msg ~ "\n"
	else
		do @textLog :~ msg ~ " (" ~ @nullStr(args[2]) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ ")\n"
	end if
	do @updateLog()
	var pos: @Pos :: #@Pos
	do pos.src :: args[2] =& null ?("", ##args[2])
	do pos.row :: row
	do pos.col :: col
	if(!@auxiliaryErr.exist(pos))
		do @auxiliaryErr.add(pos, @errStr(args[0], args[1], args[2], row, col))
	end if
end func

func errStr(code: []char, msg: []char, src: []char, row: int, col: int): []char
	ret "[" ~ @nullStr(src) ~ ": " ~ row.toStr() ~ ", " ~ col.toStr() ~ "] " ~ @nullStr(code) ~ ": " ~ @nullStr(msg)
end func

func nullStr(s: []char): []char
	ret s =& null ?("(null)", s)
end func

func setDirtyInterpret()
	do @dirtyInterpret :: 0
	do @dirtyInterpretTime :: lib@sysTime()
end func

func setDirtyHint()
	do @dirtyHint :: true
	do @dirtyHintTime :: lib@sysTime()
end func

func resetAuxiliary()
	do @auxiliaryErr :: #dict<@Pos, []char>
	do @listInfoItem :: #list<@ListInfoItem>
end func

func updateAuxiliary()
	do @auxiliaryErr.forEach(callback, null)
	do @drawEditor.paint()

	func callback(pos: @Pos, msg: []char, data: kuin@Class): bool
		var listInfoItem: @ListInfoItem :: #@ListInfoItem
		do listInfoItem.text :: msg
		do listInfoItem.pos :: pos
		do @listInfoItem.add(listInfoItem)

		; Fill in words with the error color.
		var srcName: []char :: @internalNameToSrcName(pos.src)
		if(srcName =& null)
			ret true
		end if
		var document: @Document :: @documents.get(srcName)
		if(document <>& null & document =$ @DocumentSrc)
			var document2: @DocumentSrc :: document $ @DocumentSrc
			var x: int :: pos.col - 1
			var y: int :: pos.row - 1
			var color: bit8
			if(moveWordTop(document2.src.src, document2.src.color, &x, &y, &color))
				while(x < ^document2.src.color[y] & document2.src.color[y][x].and(16#7Fb8) = color)
					do document2.src.color[y][x] :: document2.src.color[y][x].or(16#80b8)
					do x :+ 1
				end while
			end if
		end if
		ret true

		func moveWordTop(src: [][]char, srcColor: [][]bit8, x: &int, y: &int, color: &bit8): bool
			if(y < 0)
				do y :: 0
			elif(^srcColor <= y)
				do y :: ^srcColor - 1
			end if
			if(1 <= x & x < ^srcColor[y] & (src[y][x] = ' ' | src[y][x] = '\t' | srcColor[y][x].and(16#7Fb8) = %comment $ @CharColor $ bit8 | srcColor[y][x].and(16#7Fb8) = %symbol $ @CharColor $ bit8))
				do x :- 1
			end if
			if(x < 0)
				do x :: 0
			elif(^srcColor[y] <= x)
				do x :: ^srcColor[y] - 1
			end if
			if(^srcColor[y] <> 0)
				do color :: srcColor[y][x].and(16#7Fb8)
				while(x >= 1 & srcColor[y][x - 1].and(16#7Fb8) = color)
					do x :- 1
				end while
				ret true
			end if
			ret false
		end func
	end func
end func

func srcNameToInternalName(srcName: []char): []char
	if(^@sysDir <= ^srcName & @sysDir = srcName.sub(0, ^@sysDir))
		ret file@delExt(srcName.sub(^@sysDir, -1)).replace("/", "\\")
	elif(@mainSrcDir <> "" & ^@mainSrcDir <= ^srcName & @mainSrcDir = srcName.sub(0, ^@mainSrcDir))
		ret "\\" ~ file@delExt(srcName.sub(^@mainSrcDir, -1)).replace("/", "\\")
	else
		ret "\\" ~ file@delExt(file@fileName(srcName)).replace("/", "\\")
	end if
end func

func internalNameToSrcName(internalName: []char): []char
	if(internalName = @untitledInternalName)
		ret @untitledSrcName
	end if
	if(^internalName > 1 & internalName[0] = '\\')
		ret @mainSrcDir ~ internalName.sub(1, -1).replace("\\", "/") ~ ".kn"
	end if
	ret @sysDir ~ internalName.replace("\\", "/") ~ ".kn"
end func

func logForInterpret(args: [][]char, row: int, col: int)
	var pos: @Pos :: #@Pos
	do pos.src :: args[2] =& null ?("", ##args[2])
	do pos.row :: row
	do pos.col :: col
	if(!@auxiliaryErr.exist(pos))
		do @auxiliaryErr.add(pos, @errStr(args[0], args[1], args[2], row, col))
	end if
end func

func updateUi()
	do @editFile.setText("")
	do @listInfo.clear()
	if(@curDocument =$ @DocumentSrc)
		; TODO: do @listInfoItem.sort()
		do @listInfoItem.head()
		while(!@listInfoItem.term())
			do @listInfo.add(@listInfoItem.get().text)
			do @listInfoItem.next()
		end while
	elif(@curDocument =$ @DocumentArWnd)
		do @listInfo.add(@langEn ?("None", "なし"))
		do @listInfo.add("Button")
	end if

	do @listFile.clear()
	do @documents.forEach(callback, null)

	func callback(src: []char, document: @Document, data: kuin@Class): bool
		var prefix: []char :: ""
		var internalName: []char :: @srcNameToInternalName(src)
		if(document =& @curDocument)
			do prefix :~ ">"
			do @editFile.setText(internalName)
		end if
		if(document.changed)
			do prefix :~ "*"
		end if
		do @listFile.add(prefix ~ internalName)
		if(document =& @curDocument)
			do @listFile.setSel(@listFile.len() - 1)
		end if
		ret true
	end func
end func

var wndAddFile: wnd@Wnd
var wndAddFileResuiltFile: []char
var wndAddFileResuiltType: int
var wndAddFileEditFile: wnd@Edit
var wndAddFileListType: wnd@List

func addNewFile()
	if(@mainSrcDir = "")
		do wnd@msgBox(@wndMain, @langEn ?("The main source file must be saved before adding another file.", "ファイルを追加する前にメインソースファイルを保存しなければなりません。"), @title, %err, %ok)
		ret
	end if
	do @wndAddFile :: wnd@makeWnd(@wndMain, %fix, 640, 480, @langEn?("Add New File", "新しいファイルを追加"))
	do @wndAddFileResuiltFile :: null
	do @wndAddFileResuiltType :: 0
	do @wndAddFileListType :: wnd@makeList(@wndAddFile, 12, 12, 616, 100, %fix, %scale)
	do @wndAddFileListType.add(@langEn?("Source Code", "ソースコード"))
	; TODO: do @wndAddFileListType.add(@langEn?("Window", "ウインドウ"))
	do @wndAddFileListType.setSel(0)
	do @wndAddFileEditFile :: wnd@makeEdit(@wndAddFile, 12, 118, 510, 19, %fix, %fix)
	var btnFile: wnd@Btn :: wnd@makeBtn(@wndAddFile, 528, 118, 100, 23, %fix, %fix, @langEn ?("Browse...", "参照..."))
	do btnFile.onPush :: btnFileOnPush
	var btnAdd: wnd@Btn :: wnd@makeBtn(@wndAddFile, 12, 143, 100, 23, %fix, %fix, @langEn ?("Add", "追加"))
	do btnAdd.onPush :: btnAddOnPush
	do @wndAddFile.modal()
	if(@wndAddFileResuiltFile <>& null & @wndAddFileResuiltFile <> "")
		var document: @Document
		switch(@wndAddFileResuiltType)
		case 0
			do document :: #@DocumentSrc
		case 1
			do document :: #@DocumentArWnd
		end switch
		do document.init(null)
		if(@saveSrc(@wndAddFileResuiltFile, document.getSrc()))
			do @add(@wndAddFileResuiltFile)
			do @updateUi()
			; TODO: Exchange the files.
		end if
	end if
	do @wndAddFile :: null
	do @wndAddFileResuiltFile :: null
	do @wndAddFileEditFile :: null
	do @wndAddFileListType :: null

	func btnFileOnPush(wnd: wnd@WndBase)
		var path: []char :: wnd@saveFileDialog(@wndAddFile, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0, "kn")
		if(path <>& null)
			do @wndAddFileEditFile.setText(path)
		end if
	end func

	func btnAddOnPush(wnd: wnd@WndBase)
		do @wndAddFileResuiltFile :: @wndAddFileEditFile.getText().replace("\\", "/")
		do @wndAddFileResuiltType :: @wndAddFileListType.getSel()
		do @wndAddFile.close()
	end func
end func

func addExistingFile()
	if(@mainSrcDir = "")
		do wnd@msgBox(@wndMain, @langEn ?("The main source file must be saved before adding another file.", "ファイルを追加する前にメインソースファイルを保存しなければなりません。"), @title, %err, %ok)
		ret
	end if
	var file: []char :: wnd@openFileDialog(@wndMain, [@langEn ?("Kuin source code (*.kn)", "Kuinソースコード (*.kn)"), "*.kn"], 0)
	if(file <>& null)
		do @add(file)
		do @updateUi()
		; TODO: Exchange the files.
	end if
end func

func arBaseParseWord(src: []char, ptr: &int): []char
	var last: int :: ptr
	while(last < ^src & src[last] <> ',')
		do last :+ 1
	end while
	var word: []char :: src.sub(ptr, last - ptr)
	do ptr :: last + 1
	ret word
end func

func lockEditor(lock: bool)
	do @lockingEditor :: lock
	do @btnCompile.enable(!lock)
	do @btnRls.enable(!lock)
end func

func updateLog()
	do @editHint.setText(@textErr ~ (@textErr =& null ?("", "\n\n")) ~ @textHint ~ (@textHint =& null ?("", "\n\n")) ~ @textFunc)
	do @editLog.setText(@textLog)
end func

class GetDocumentNameClass()
	+var src: []char
	+var document: @Document
end class

func getDocumentName(document: @Document): []char
	var getSrcClass: @GetDocumentNameClass :: #@GetDocumentNameClass
	do getSrcClass.src :: null
	do getSrcClass.document :: document
	do @documents.forEach(callback, getSrcClass)
	ret getSrcClass.src

	func callback(src: []char, document: @Document, param: @GetDocumentNameClass): bool
		if(document =& param.document)
			do param.src :: src
			ret false
		end if
		ret true
	end func
end func

func getHint2(src: []char, row: int, col: int, keyword: []char): []char
	var result: []char
	try
		do result :: ##@getHint(src, row, col, keyword)
	catch
		do result :: null
	end try
	ret result
end func

func delRunningFiles()
	do @runningFiles.head()
	while loop(!@runningFiles.term())
		var dir: []char :: file@sysDir(%appData) ~ "Kuin/" ~ @runningFiles.get() ~ "/"
		try
			if(file@delDir(dir))
				do @runningFiles.del()
				skip loop
			end if
		catch
		end try
		do @runningFiles.next()
	end while
end func

func addRunningFileName(): []char
	var uuid: []char :: lib@rndUuid()
	do @runningFiles.add(uuid)
	ret uuid
end func

var wndFind: wnd@Wnd
var wndFindTabFind: wnd@Tab
var wndFindEditPattern: wnd@Edit
var wndFindEditReplace: wnd@Edit
var wndFindRadioDocument: wnd@Radio
var wndFindRadioAll: wnd@Radio
var wndFindRadioSelection: wnd@Radio
var wndFindChkDistinguishCase: wnd@Chk
var wndFindChkOnlyWord: wnd@Chk
var wndFindChkRegularExpression: wnd@Chk
var wndFindBtnPrev: wnd@Btn
var wndFindBtnNext: wnd@Btn
var wndFindBtnReplace: wnd@Btn
var wndFindBtnReplaceAll: wnd@Btn
var wndFindEditPatternLast: []char
var wndFindEditReplaceLast: []char
var wndFindRadioLast: int
var wndFindChkDistinguishCaseLast: bool
var wndFindChkOnlyWordLast: bool
var wndFindChkRegularExpressionLast: bool

func showFind(replace: bool)
	if(@wndFind =& null)
		do @wndFind :: wnd@makeWnd(@wndMain, %fix, 380, 332, @langEn ?("Find and Replace", "検索と置換"))
		do @wndFind.onClose :: wndFindOnClose
		do @wndFindTabFind :: wnd@makeTab(@wndFind, 12, 12, 356, 308, %scale, %scale)
		do @wndFindTabFind.add("検索")
		do @wndFindTabFind.add("置換")
		do @wndFindTabFind.onSel :: wndFindTabFindOnSel
		do wnd@makeLabel(@wndFindTabFind, 6, 28, 324, 12, %fix, %fix, @langEn ?("Find what:", "検索する文字列:"))
		do @wndFindEditPattern :: wnd@makeEdit(@wndFindTabFind, 6, 46, 344, 19, %scale, %fix)
		do @wndFindEditPattern.onChange :: wndFindEditPatternOnChange
		do wnd@makeLabel(@wndFindTabFind, 6, 71, 324, 12, %fix, %fix, @langEn ?("Replace with:", "置換後の文字列:"))
		do @wndFindEditReplace :: wnd@makeEdit(@wndFindTabFind, 6, 89, 344, 19, %scale, %fix)
		do @wndFindEditReplace.onChange :: wndFindEditReplaceOnChange
		var groupTarget: wnd@Group :: wnd@makeGroup(@wndFindTabFind, 6, 114, 344, 84, %scale, %fix, @langEn ?("Look in", "検索対象"))
		do @wndFindRadioDocument :: wnd@makeRadio(groupTarget, 6, 18, 312, 16, %fix, %fix, @langEn ?("Current document", "現在のドキュメント"))
		do @wndFindRadioAll :: wnd@makeRadio(groupTarget, 6, 40, 312, 16, %fix, %fix, @langEn ?("All documents", "すべてのドキュメント"))
		do @wndFindRadioSelection :: wnd@makeRadio(groupTarget, 6, 62, 312, 16, %fix, %fix, @langEn ?("Selection", "選択範囲"))
		do @wndFindChkDistinguishCase :: wnd@makeChk(@wndFindTabFind, 6, 204, 166, 16, %fix, %fix, @langEn ?("Match case", "大文字と小文字を区別する"))
		do @wndFindChkDistinguishCase.onPush :: wndFindChkDistinguishCaseOnPush
		do @wndFindChkOnlyWord :: wnd@makeChk(@wndFindTabFind, 6, 226, 166, 16, %fix, %fix, @langEn ?("Match whole word", "単語単位"))
		do @wndFindChkOnlyWord.onPush :: wndFindChkOnlyWordOnPush
		do @wndFindChkRegularExpression :: wnd@makeChk(@wndFindTabFind, 6, 248, 166, 16, %fix, %fix, @langEn ?("Use Regular Expressions", "正規表現を使用する"))
		do @wndFindChkRegularExpression.onPush :: wndFindChkRegularExpressionOnPush
		do @wndFindBtnPrev :: wnd@makeBtn(@wndFindTabFind, 178, 212, 75, 23, %fix, %fix, @langEn ?("Find Previous", "前を検索"))
		do @wndFindBtnPrev.onPush :: wndFindBtnPrevOnPush
		do @wndFindBtnNext :: wnd@makeBtn(@wndFindTabFind, 178, 241, 75, 23, %fix, %fix, @langEn ?("Find Next", "次を検索"))
		do @wndFindBtnNext.onPush :: wndFindBtnNextOnPush
		do @wndFindBtnReplace :: wnd@makeBtn(@wndFindTabFind, 259, 212, 75, 23, %fix, %fix, @langEn ?("Replace", "置換"))
		do @wndFindBtnReplace.onPush :: wndFindBtnReplaceOnPush
		do @wndFindBtnReplaceAll :: wnd@makeBtn(@wndFindTabFind, 259, 241, 75, 23, %fix, %fix, @langEn ?("Replace All", "すべて置換"))
		do @wndFindBtnReplaceAll.onPush :: wndFindBtnReplaceAllOnPush
		if(@wndFindEditPatternLast <>& null)
			do @wndFindEditPattern.setText(@wndFindEditPatternLast)
		end if
		if(@wndFindEditReplaceLast <>& null)
			do @wndFindEditReplace.setText(@wndFindEditReplaceLast)
		end if
		switch(@wndFindRadioLast)
		case 1
			do @wndFindRadioAll.setChk(true)
		case 2
			do @wndFindRadioSelection.setChk(true)
		default
			do @wndFindRadioDocument.setChk(true)
		end switch
		do @wndFindChkDistinguishCase.setChk(@wndFindChkDistinguishCaseLast)
		do @wndFindChkOnlyWord.setChk(@wndFindChkOnlyWordLast)
		do @wndFindChkRegularExpression.setChk(@wndFindChkRegularExpressionLast)

		do @tabOrderFind :: wnd@makeTabOrder([@wndFindEditPattern $ wnd@WndBase, @wndFindEditReplace, @wndFindBtnPrev, @wndFindBtnNext, @wndFindBtnReplace, @wndFindBtnReplaceAll])
	else
		do @wndFind.setActive()
	end if
	do @wndFindTabFind.setSel(replace ?(1, 0))
	do @wndFindEditReplace.enable(replace)
	do @wndFindBtnReplace.enable(replace)
	do @wndFindBtnReplaceAll.enable(replace)
	do wndFindChkRegularExpressionOnPush(null)
	do @wndFindEditPattern.focus()
	do @wndFindEditPattern.setSel(0, -1)

	; TODO:
	do @wndFindRadioAll.enable(false)
	do @wndFindRadioSelection.enable(false)

	func wndFindOnClose(wnd: wnd@Wnd): bool
		do @tabOrderFind :: null

		do @wndFindEditPatternLast :: @wndFindEditPattern.getText()
		do @wndFindEditReplaceLast :: @wndFindEditReplace.getText()
		if(@wndFindRadioAll.getChk())
			do @wndFindRadioLast :: 1
		elif(@wndFindRadioSelection.getChk())
			do @wndFindRadioLast :: 2
		else
			do @wndFindRadioLast :: 0
		end if
		do @wndFindChkDistinguishCaseLast :: @wndFindChkDistinguishCase.getChk()
		do @wndFindChkOnlyWordLast :: @wndFindChkOnlyWord.getChk()
		do @wndFindChkRegularExpressionLast :: @wndFindChkRegularExpression.getChk()

		do @wndFind :: null
		do @wndFindTabFind :: null
		do @wndFindEditPattern :: null
		do @wndFindEditReplace :: null
		do @wndFindRadioDocument :: null
		do @wndFindRadioAll :: null
		do @wndFindRadioSelection :: null
		do @wndFindChkDistinguishCase :: null
		do @wndFindChkOnlyWord :: null
		do @wndFindChkRegularExpression :: null
		do @wndFindBtnPrev :: null
		do @wndFindBtnNext :: null
		do @wndFindBtnReplace :: null
		do @wndFindBtnReplaceAll :: null
		ret true
	end func

	func wndFindTabFindOnSel(wnd: wnd@Tab)
		var sel: int :: @wndFindTabFind.getSel()
		if(sel = -1)
			ret
		end if
		var replace: bool :: sel = 1
		do @wndFindEditReplace.enable(replace)
		do @wndFindBtnReplace.enable(replace)
		do @wndFindBtnReplaceAll.enable(replace)
	end func

	func wndFindEditPatternOnChange(wnd: wnd@Edit)
		do @wndFindEditPatternLast :: @wndFindEditPattern.getText()
	end func

	func wndFindEditReplaceOnChange(wnd: wnd@Edit)
		do @wndFindEditReplaceLast :: @wndFindEditReplace.getText()
	end func

	func wndFindChkDistinguishCaseOnPush(wnd: wnd@Chk)
		do @wndFindChkDistinguishCaseLast :: @wndFindChkDistinguishCase.getChk()
	end func

	func wndFindChkOnlyWordOnPush(wnd: wnd@Chk)
		do @wndFindChkOnlyWordLast :: @wndFindChkOnlyWord.getChk()
	end func

	func wndFindChkRegularExpressionOnPush(wnd: wnd@Chk)
		do @wndFindChkRegularExpressionLast :: @wndFindChkRegularExpression.getChk()
		do @wndFindChkDistinguishCase.enable(!@wndFindChkRegularExpressionLast)
		do @wndFindChkOnlyWord.enable(!@wndFindChkRegularExpressionLast)
	end func

	func wndFindBtnPrevOnPush(wnd: wnd@Btn)
		do @findPrev(@wndFindEditPatternLast, @wndFindChkDistinguishCaseLast, @wndFindChkOnlyWordLast, @wndFindChkRegularExpressionLast)
	end func

	func wndFindBtnNextOnPush(wnd: wnd@Btn)
		do @findNext(@wndFindEditPatternLast, @wndFindChkDistinguishCaseLast, @wndFindChkOnlyWordLast, @wndFindChkRegularExpressionLast)
	end func

	func wndFindBtnReplaceOnPush(wnd: wnd@Btn)
		do @replaceOne(@wndFindEditPatternLast, @wndFindEditReplaceLast, @wndFindChkDistinguishCaseLast, @wndFindChkOnlyWordLast, @wndFindChkRegularExpressionLast)
	end func

	func wndFindBtnReplaceAllOnPush(wnd: wnd@Btn)
		do @replaceAll(@wndFindEditPatternLast, @wndFindEditReplaceLast, @wndFindChkDistinguishCaseLast, @wndFindChkOnlyWordLast, @wndFindChkRegularExpressionLast)
	end func
end func

func findPrev(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	if(!@curDocument.findPrev(pattern, distinguishCase, onlyWord, regularExpression))
		do wnd@msgBox(@wndFind, @langEn ?("No strings match your search.", "検索した単語は見つかりませんでした。"), @title, %info, %ok)
	end if
end func

func findNext(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	if(!@curDocument.findNext(pattern, distinguishCase, onlyWord, regularExpression))
		do wnd@msgBox(@wndFind, @langEn ?("No strings match your search.", "検索した単語は見つかりませんでした。"), @title, %info, %ok)
	end if
end func

func replaceOne(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	do @curDocument.replaceOne(pattern, replaceStr, distinguishCase, onlyWord, regularExpression)
	if(!@curDocument.findNext(pattern, distinguishCase, onlyWord, regularExpression))
		do wnd@msgBox(@wndFind, @langEn ?("No strings match your search.", "検索した単語は見つかりませんでした。"), @title, %info, %ok)
	end if
end func

func replaceAll(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
	var msg: []char
	if(@langEn)
		do msg :: "Do you want to replace all \"" ~ pattern ~ "\" with \"" ~ replaceStr ~ "\" in the current document?"
	else
		do msg :: "現在のドキュメントの「" ~ pattern ~ "」を「" ~ replaceStr ~ "」に、すべて置換しますか？"
	end if
	if(wnd@msgBox(@wndFind, msg, @title, %warn, %yesNoCancel) = %yes)
		var cnt: int :: @curDocument.replaceAll(pattern, replaceStr, distinguishCase, onlyWord, regularExpression)
		if(@langEn)
			do msg :: cnt.toStr() ~ " string(s) have been replaced."
		else
			do msg :: cnt.toStr() ~ "個の文字列を置換しました。"
		end if
		do wnd@msgBox(@wndFind, msg, @title, %info, %ok)
	end if
end func

func findStr(found: &[]char, text: []char, fromLast: bool, first: int, last: int, pattern: []char, distinguishCase: bool, onlyWord: bool, regex: regex@Regex): int
	var pos: int
	if(regex =& null)
		do pos :: text.findStrEx(pattern, fromLast ?(last, first), fromLast, !distinguishCase, onlyWord)
		if(pos < first | last < pos)
			do pos :: -1
		end if
		do found :: pattern
		ret pos
	else
		var word: [][]char
		if(fromLast)
			do word :: regex.findLast(&pos, text, last)
		else
			do word :: regex.find(&pos, text, first)
		end if
		if(pos <> -1)
			do found :: word[0]
		end if
		ret pos
	end if
	ret -1
end func

func showMsgRunning()
	do wnd@msgBox(@wndMain, @langEn ?("The program is running.", "プログラムが実行中です。"), @title, %err, %ok)
end func
