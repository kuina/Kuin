+enum CharColor
	none
	identifier
	global
	reserved
	num
	str
	char_
	lineComment
	comment
	symbol
	max
end enum

+class ErrListItem()
	+var text: []char
	+var pos: \src@Pos
	
	+*func cmp(t: kuin@Class): int
		ret me.pos.cmp((t $ @ErrListItem).pos)
	end func
end class

var srcCharColor: []int
var lineClipboardFormats: []int

+func init()
	do @srcCharColor :: #[%max $ @CharColor $ int]int
	do @srcCharColor[%none $ @CharColor $ int] :: 0xFF999999
	do @srcCharColor[%identifier $ @CharColor $ int] :: 0xFF009BEA
	do @srcCharColor[%global $ @CharColor $ int] :: 0xFFCC00F6
	do @srcCharColor[%reserved $ @CharColor $ int] :: 0xFF1400F6
	do @srcCharColor[%num $ @CharColor $ int] :: 0xFFEA0062
	do @srcCharColor[%str $ @CharColor $ int] :: 0xFFEA0062
	do @srcCharColor[%char_ $ @CharColor $ int] :: 0xFFEA0062
	do @srcCharColor[%lineComment $ @CharColor $ int] :: 0xFF1EB000
	do @srcCharColor[%comment $ @CharColor $ int] :: 0xFF1EB000
	do @srcCharColor[%symbol $ @CharColor $ int] :: 0xFF666666
	var lineClipboardFormatNames: [][]char :: ["MSDEVLineSelect", "VisualStudioEditorOperationsLineCutCopyClipboardTag"]
	do @lineClipboardFormats :: #[^lineClipboardFormatNames]int
	for i(0, ^lineClipboardFormatNames - 1)
		do @lineClipboardFormats[i] :: wnd@registerClipboardFormat(lineClipboardFormatNames[i])
	end for
end func

+class DocSrc(\doc@Doc)
	*func ctor()
		do super(me)
		do me.undo :: undo@makeUndo(8192)
		
		do me.src :: #Src
		do me.src.src :: null
		do me.src.color :: null
		do me.src.commentLevel :: null
		do me.src.flags :: null
		do me.pageX :: 0
		do me.pageY :: 0
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		do me.lineNumWidth :: 0
		do me.setSrc(null)
		do me.resetListInfoItem()
		do me.dirtyLine :: -1
		do me.forceToInterpret1 :: false
		do me.caretX :: -1
		do me.caretY :: -1
		do me.caretShown :: false
		do me.sys :: false
	end func
	
	+*func fix(first: bool)
		do me.forceToInterpret1 :: true
		if(first)
			do me.dirtyLine :: 2 {Force to run 'interpret2'.}
		end if
		do me.interpret1SetDirty(-1, false, false)
	end func
	
	+*func load(path: []char, sys: bool): bool
		var src: list<[]char> :: #list<[]char>
		var filePtr: file@Reader :: file@makeReader(path)
		if(filePtr =& null)
			ret false
		end if
		var doc: \doc@Doc :: null
		while loop(!filePtr.term())
			var line: []char :: filePtr.readLine()
			do src.add(line)
		end while
		do filePtr.fin()
		do me.setSrc(src.toArray())
		do me.sys :: sys
		ret true
	end func
	
	+*func save(path: []char): bool
		var filePtr: file@Writer :: file@makeWriter(path, false)
		if(filePtr =& null)
			ret false
		end if
		var src: [][]char :: me.src.src
		for line(0, ^src - 1)
			do filePtr.writeStr(src[line])
			if(line <> ^src - 1 | src[line] <> "")
				do filePtr.writeChar('\n')
			end if
		end for
		do filePtr.fin()
		ret true
	end func
	
	+*func getSrc(): [][]char
		ret me.src.src
	end func
	
	+*func draw(width: int, height: int)
		do draw@rect(0.0, 0.0, width $ float, height $ float, \form@getLockingEditor() | me.lock ?(\common@colorBackLocked, \common@colorBack))
		var lineX: float :: (me.lineNumWidth - 2) $ float
		do draw@line(lineX, 0.0, lineX, height $ float, colorLineNum)
		for i(0, ^me.src.src - 1 - me.pageY)
			var y: float :: (i * \common@cellHeight) $ float
			if(y < -\common@cellHeight $ float | y >= (height + \common@cellHeight) $ float)
				skip i
			end if
			var str: []char :: (me.pageY + i + 1).toStr()
			var flags: LineFlag :: me.pageY + i >= ^me.src.flags ?(%none, me.src.flags[me.pageY + i])
			if(flags.and(%breakPoint) <> %none)
				do draw@rect(1.0, y + 1.0, lineX - 2.0, \common@cellHeight $ float - 2.0, colorBreakPointBack)
				if(\src@breakPos <>& null & \src@breakPos.src = \src@curDocName & \src@breakPos.row = me.pageY + i + 1)
					do draw@rect(1.0, y + 1.0, (lineX - 2.0) / 2.0, \common@cellHeight $ float - 2.0, colorBreakBack)
				end if
				do \common@font.draw((me.lineNumWidth - (^str + 1) * \common@cellWidth + \common@cellWidth / 2) $ float, y, str, colorBreakPoint)
			else
				if(\src@breakPos <>& null & \src@breakPos.src = \src@curDocName & \src@breakPos.row = me.pageY + i + 1)
					do draw@rect(1.0, y + 1.0, (lineX - 2.0) / 2.0, \common@cellHeight $ float - 2.0, colorBreakBack)
				end if
				do \common@font.draw((me.lineNumWidth - (^str + 1) * \common@cellWidth + \common@cellWidth / 2) $ float, y, str, colorLineNum)
			end if
		end for
		
		var areaX1: int :: me.areaX
		var areaY1: int :: me.areaY
		var areaX2: int :: me.cursorX
		var areaY2: int :: me.cursorY
		if(me.areaSel() & (areaY1 > areaY2 | areaY1 = areaY2 & areaX1 > areaX2))
			var tmp: int
			do tmp :: areaX1
			do areaX1 :: areaX2
			do areaX2 :: tmp
			do tmp :: areaY1
			do areaY1 :: areaY2
			do areaY2 :: tmp
		end if
		for i(0, height / \common@cellHeight)
			if(me.pageY + i >= ^me.src.src)
				break i
			end if
			var str: []char :: me.src.src[me.pageY + i]
			var left: int :: me.lineNumWidth - me.pageX * \common@cellWidth
			var x: int :: 0
			for j(0, ^str)
				assert j = ^str | str[j] <> 0x01 $ char & str[j] <> '\n'
				var x2: int :: left + x * \common@cellWidth
				if(x2 >= width)
					break j
				end if
				var charWidth: int :: j < ^str ?(me.charWidth(str[j], x), 0)
				if(x2 >= me.lineNumWidth)
					var inArea: bool :: false
					if(me.areaSel())
						var areaX3: int :: j
						var areaY3: int :: me.pageY + i
						if(areaY3 < areaY1 | areaY2 < areaY3)
							; Do nothing.
						elif(areaY1 < areaY3 & areaY3 < areaY2)
							do inArea :: true
						elif(areaY1 = areaY2)
							do inArea :: areaX1 <= areaX3 & areaX3 < areaX2
						elif(areaY3 = areaY1)
							do inArea :: areaX1 <= areaX3
						else
							assert areaY3 = areaY2
							do inArea :: areaX3 < areaX2
						end if
					end if
					var textX: float :: x2 $ float
					var textY: float :: (i * \common@cellHeight) $ float
					if(j = ^str)
						if(inArea)
							do draw@rect(textX, textY, \common@cellWidth $ float, \common@cellHeight $ float, colorAreaBack)
						end if
						do \common@tex.draw(textX, textY, me.pageY + i = ^me.src.src - 1 ?(18.0, 0.0), 0.0, 9.0, 18.0, draw@white)
					else
						var color: int
						if(inArea)
							do draw@rect(textX, textY, (\common@cellWidth * (charWidth <= 0 ?(1, charWidth))) $ float, \common@cellHeight $ float, colorAreaBack)
							do color :: draw@white
						elif(me.src.color[me.pageY + i][j].and(0x80b8) <> 0 $ @CharColor $ bit8)
							do draw@rect(textX, textY, (\common@cellWidth * (charWidth <= 0 ?(1, charWidth))) $ float, \common@cellHeight $ float, colorErrBack)
							do color :: draw@white
						else
							do color :: @srcCharColor[me.src.color[me.pageY + i][j].and(0x7Fb8) $ int]
						end if
						switch(str[j])
						case '\t'
							do \common@tex.draw(textX, textY, 9.0, 0.0, 9.0, 18.0, draw@white)
						case 'ã€€'
							do \common@tex.draw(textX, textY, 27.0, 0.0, 18.0, 18.0, draw@white)
						default
							do \common@font.draw(textX, textY, str[j].toStr(), color)
						end switch
					end if
				end if
				if(j <> ^str)
					do x :+ charWidth
				end if
			end for
		end for
		
		do draw@rect(me.caretX $ float, me.caretY $ float, 2.0, \common@cellHeight $ float, 0xFF000000)
	end func
	
	+*func mouseDownL(x: int, y: int)
		do me.setArea(wnd@key(%shift) ?(%shift $ wnd@ShiftCtrl, %none))
		do me.mousePosToCharPos(x, y)
		do me.refreshCursor(false, true, true)
		if(!me.areaSel())
			do me.areaX :: me.cursorX
			do me.areaY :: me.cursorY
		end if
		do me.absoluteX :: 0
		do me.interpret1SetDirty(me.cursorY, false, false)
		do \completion@close()
		do \form@paintDrawEditor(false)
	end func
	
	+*func mouseUpL(x: int, y: int)
		do me.refreshCursor(false, true, true)
	end func
	
	+*func mouseDoubleClick(x: int, y: int)
		do me.mousePosToCharPos(x, y)
		do me.refreshCursor(false, true, true)
		do me.areaX :: me.cursorX
		do me.areaY :: me.cursorY
		do me.absoluteX :: 0
		if(me.cursorX = ^me.src.src[me.cursorY])
			do me.areaX :- 1
			if(me.areaX < 0)
				do me.areaX :: 0
			end if
		end if
		if(^me.src.src[me.cursorY] > 0)
			var color: bit8 :: me.src.color[me.areaY][me.areaX].and(0x7Fb8)
			while(me.areaX > 0 & me.src.color[me.areaY][me.areaX - 1].and(0x7Fb8) = color)
				do me.areaX :- 1
			end while
			while(me.cursorX < ^me.src.src[me.cursorY] & me.src.color[me.cursorY][me.cursorX].and(0x7Fb8) = color)
				do me.cursorX :+ 1
			end while
		end if
		do me.interpret1SetDirty(me.cursorY, false, false)
		do \form@paintDrawEditor(false)
	end func
	
	+*func mouseMove(x: int, y: int)
		if(\form@dragging())
			do me.mousePosToCharPos(x, y)
			do me.refreshCursor(false, true, true)
			do me.interpret1SetDirty(me.cursorY, false, false)
			do \form@paintDrawEditor(true)
		end if
	end func
	
	+*func focus(isFocus: bool)
		if(isFocus)
			do me.caretShown :: true
			do me.updateScrollBar()
		else
			do me.caretShown :: false
		end if
	end func
	
	+*func updateScrollBar()
		do me.refreshCursor(false, true, false)
	end func
	
	+*func keyDown(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl): bool
		switch(key)
		case %ctrl
			if(\completion@displayed())
				do \completion@setAlpha(25)
			end if
			ret true
		case %bs
			if(me.locked())
				ret true
			end if
			if(shiftCtrl = %none)
				do me.undoRecordBegin()
				if(me.areaSel())
					do me.delAreaStr()
				else
					do me.bs(me.cursorX, me.cursorY, 1, true)
				end if
				do me.interpret1SetDirty(me.cursorY, true, false)
				do me.undoRecordEnd()
				do me.refreshCursor(false, true, true)
				do \form@paintDrawEditor(false)
				ret true
			end if
		case %tab
			switch(shiftCtrl)
			case %none
				if(me.locked())
					ret true
				end if
				if(!me.areaSel())
					do me.undoRecordBegin()
					do me.ins(me.cursorX, me.cursorY, "\t", true)
					do me.interpret1SetDirty(me.cursorY, true, false)
					do me.undoRecordEnd()
					do me.refreshCursor(false, true, true)
					do \form@paintDrawEditor(false)
				else
					do me.indentAreaStr()
					do me.refreshCursor(false, true, true)
					do \form@paintDrawEditor(false)
				end if
				ret true
			case %shift
				if(me.locked())
					ret true
				end if
				if(me.areaSel())
					do me.unindentAreaStr()
					do me.refreshCursor(false, true, true)
					do \form@paintDrawEditor(false)
				end if
				ret true
			end switch
		case %enter
			if(me.locked())
				ret true
			end if
			if(shiftCtrl = %none)
				if(!me.complementImpl())
					do me.undoRecordBegin()
					if(me.areaSel())
						do me.delAreaStr()
					end if
					do me.ins(me.cursorX, me.cursorY, "\n", true)
					do me.interpret1SetDirty(me.cursorY, true, false)
					do me.undoRecordEnd()
					do me.refreshCursor(false, true, true)
					do \form@paintDrawEditor(false)
				end if
				ret true
			end if
		case %pageUp
			block
				var height: int
				do \form@drawEditor.getPos(&, &, &, &height)
				if(shiftCtrl = %ctrl)
					do me.scrollPageY(-height / \common@cellHeight)
				else
					do me.setArea(shiftCtrl)
					var absoluteX: int :: me.getAbsoluteX()
					do me.cursorY :- height / \common@cellHeight
					do me.setAbsoluteX(absoluteX)
					do me.refreshCursor(false, true, true)
					do me.interpret1SetDirty(me.cursorY, false, false)
				end if
				do \form@paintDrawEditor(false)
				ret true
			end block
		case %pageDown
			block
				var height: int
				do \form@drawEditor.getPos(&, &, &, &height)
				if(shiftCtrl = %ctrl)
					do me.scrollPageY(height / \common@cellHeight)
				else
					do me.setArea(shiftCtrl)
					var absoluteX: int :: me.getAbsoluteX()
					do me.cursorY :+ height / \common@cellHeight
					do me.setAbsoluteX(absoluteX)
					do me.refreshCursor(false, true, true)
					do me.interpret1SetDirty(me.cursorY, false, false)
				end if
				do \form@paintDrawEditor(false)
				ret true
			end block
		case %end_
			do me.setArea(shiftCtrl)
			do me.cursorX :: lib@intMax
			do me.absoluteX :: 0
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: lib@intMax
			end if
			do me.refreshCursor(false, true, true)
			do \completion@close()
			do \form@paintDrawEditor(false)
			do me.interpret1SetDirty(me.cursorY, false, false)
			ret true
		case %home
			do me.setArea(shiftCtrl)
			do me.cursorX :: 0
			do me.absoluteX :: 0
			if(shiftCtrl.and(%ctrl) <> %none)
				do me.cursorY :: 0
			end if
			do me.refreshCursor(false, true, true)
			do \completion@close()
			do \form@paintDrawEditor(false)
			do me.interpret1SetDirty(me.cursorY, false, false)
			ret true
		case %left
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(-1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :- 1
				do me.absoluteX :: 0
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
			end if
			do \completion@close()
			do \form@paintDrawEditor(false)
			ret true
		case %up
			if(shiftCtrl = %none & \completion@displayed() & \completion@moveCursorUp())
				; Do nothing.
			elif(shiftCtrl = %ctrl)
				do me.scrollPageY(-1)
				do \form@paintDrawEditor(false)
			elif(wnd@key(%alt))
				if(me.areaSel())
					if(lib@min(me.areaY, me.cursorY) <> 0)
						do me.undoRecordBegin()
						var x1: int :: me.areaX
						var y1: int :: me.areaY
						var x2: int :: me.cursorX
						var y2: int :: me.cursorY
						var yDel: int :: lib@min(y1, y2) - 1
						var yIns: int :: lib@max(y1, y2)
						do me.ins(^me.src.src[yIns], yIns, "\n" ~ me.src.src[yDel], true)
						do me.del(0, yDel, ^me.src.src[yDel] + 1, true)
						do me.areaX :: x1
						do me.areaY :: y1 - 1
						do me.cursorX :: x2
						do me.cursorY :: y2 - 1
						do me.interpret1SetDirty(me.cursorY, true, false)
						do me.undoRecordEnd()
					end if
				else
					if(me.cursorY <> 0)
						do me.undoRecordBegin()
						var x: int :: me.cursorX
						var y: int :: me.cursorY
						var yDel: int :: y - 1
						var yIns: int :: y
						do me.ins(^me.src.src[yIns], yIns, "\n" ~ me.src.src[yDel], true)
						do me.del(0, yDel, ^me.src.src[yDel] + 1, true)
						do me.cursorX :: x
						do me.cursorY :: y - 1
						do me.interpret1SetDirty(me.cursorY, true, false)
						do me.undoRecordEnd()
					end if
				end if
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :- 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
			end if
			ret true
		case %right
			if(shiftCtrl = %ctrl)
				do me.scrollPageX(1)
			else
				do me.setArea(shiftCtrl)
				do me.cursorX :+ 1
				do me.absoluteX :: 0
				do me.refreshCursor(true, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
			end if
			do \completion@close()
			do \form@paintDrawEditor(false)
			ret true
		case %down
			if(shiftCtrl = %none & \completion@displayed() & \completion@moveCursorDown())
				; Do nothing.
			elif(shiftCtrl = %ctrl)
				do me.scrollPageY(1)
				do \form@paintDrawEditor(false)
			elif(wnd@key(%alt))
				if(me.areaSel())
					if(lib@max(me.areaY, me.cursorY) <> ^me.src.src - 1)
						do me.undoRecordBegin()
						var x1: int :: me.areaX
						var y1: int :: me.areaY
						var x2: int :: me.cursorX
						var y2: int :: me.cursorY
						var yIns: int :: lib@min(y1, y2)
						var yDel: int :: lib@max(y1, y2) + 1
						do me.ins(0, yIns, me.src.src[yDel] ~ "\n", true)
						do me.del(^me.src.src[yDel], yDel, ^me.src.src[yDel + 1] + 1, true)
						do me.areaX :: x1
						do me.areaY :: y1 + 1
						do me.cursorX :: x2
						do me.cursorY :: y2 + 1
						do me.interpret1SetDirty(me.cursorY, true, false)
						do me.undoRecordEnd()
					end if
				else
					if(me.cursorY <> ^me.src.src - 1)
						do me.undoRecordBegin()
						var x: int :: me.cursorX
						var y: int :: me.cursorY
						var yIns: int :: y
						var yDel: int :: y + 1
						do me.ins(0, yIns, me.src.src[yDel] ~ "\n", true)
						do me.del(^me.src.src[yDel], yDel, ^me.src.src[yDel + 1] + 1, true)
						do me.cursorX :: x
						do me.cursorY :: y + 1
						do me.interpret1SetDirty(me.cursorY, true, false)
						do me.undoRecordEnd()
					end if
				end if
			else
				do me.setArea(shiftCtrl)
				var absoluteX: int :: me.getAbsoluteX()
				do me.cursorY :+ 1
				do me.setAbsoluteX(absoluteX)
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
			end if
			ret true
		case %ins
			; TODO: Insert mode.
		end switch
		ret false
	end func
	
	+*func keyUp(key: wnd@Key, shiftCtrl: wnd@ShiftCtrl)
		switch(key)
		case %ctrl
			if(\completion@displayed())
				do \completion@setAlpha(230)
			end if
		end switch
	end func
	
	+*func keyChar(key: char)
		if(me.locked())
			ret
		end if
		if(key = '\t' | me.charWidth(key, 0) = 0)
			ret
		end if
		if(\completion@displayed() & !('a' <= key & key <= 'z' | 'A' <= key & key <= 'Z' | '0' <= key & key <= '9' | key = '_' | key = '@' | key = '\\'))
			do me.complementImpl()
		end if
		do me.undoRecordBegin()
		if(me.areaSel())
			do me.delAreaStr()
		end if
		do me.ins(me.cursorX, me.cursorY, [key], true)
		do me.interpret1SetDirty(me.cursorY, true, true)
		do me.undoRecordEnd()
		do me.refreshCursor(false, true, true)
		do \form@paintDrawEditor(false)
	end func
	
	+*func scrollX(pos: int)
		do me.pageX :: pos
		do me.refreshCursor(false, false, false)
		do \form@paintDrawEditor(true)
	end func
	
	+*func scrollY(pos: int)
		do me.pageY :: pos
		do me.refreshCursor(false, false, false)
		do \form@paintDrawEditor(true)
	end func
	
	+*func wheelX(wheel: int)
		do me.scrollPageX(wheel)
	end func
	
	+*func wheelY(wheel: int)
		do me.scrollPageY(wheel * 3)
	end func
	
	+*func setMouseImg(): wnd@MouseImg
		ret %ibeam
	end func
	
	+*func cmdUndo()
		if(me.locked())
			ret
		end if
		if(me.areaSel())
			do me.areaX :: -1
		end if
		do me.undo.undo()
		do me.refreshCursor(false, true, true)
		do \form@paintDrawEditor(false)
	end func
	
	+*func cmdRedo()
		if(me.locked())
			ret
		end if
		if(me.areaSel())
			do me.areaX :: -1
		end if
		do me.undo.redo()
		do me.refreshCursor(false, true, true)
		do \form@paintDrawEditor(false)
	end func
	
	+*func cmdCut()
		if(me.locked())
			ret
		end if
		do me.undoRecordBegin()
		if(me.areaSel())
			do me.copyAreaStr()
			do me.delAreaStr()
		else
			do me.copyLineStr()
			do me.delLine(me.cursorX, me.cursorY, true)
		end if
		do me.interpret1SetDirty(me.cursorY, true, false)
		do me.undoRecordEnd()
		do me.refreshCursor(false, true, true)
		do \form@paintDrawEditor(false)
	end func
	
	+*func cmdCopy()
		if(me.areaSel())
			do me.copyAreaStr()
		else
			do me.copyLineStr()
		end if
	end func
	
	+*func cmdPaste()
		if(me.locked())
			ret
		end if
		var str: []char :: wnd@getClipboardStr()
		if(str <>& null)
			do me.undoRecordBegin()
			var cursorX: int :: 0
			if(me.areaSel())
				do me.delAreaStr()
				do me.ins(me.cursorX, me.cursorY, str, true)
			elif(!isLinePaste())
				do me.ins(me.cursorX, me.cursorY, str, true)
			else
				do me.insLine(me.cursorX, me.cursorY, str, true)
			end if
			do me.interpret1SetDirty(me.cursorY, true, false)
			do me.undoRecordEnd()
			do me.refreshCursor(false, true, true)
			do \form@paintDrawEditor(false)
		end if
		
		func isLinePaste(): bool
			for i(0, ^@lineClipboardFormats - 1)
				if(wnd@isClipboardFormatAvailable(@lineClipboardFormats[i]))
					ret true
				end if
			end for
			ret false
		end func
	end func
	
	+*func cmdDel()
		if(me.locked())
			ret
		end if
		do me.undoRecordBegin()
		if(me.areaSel())
			do me.delAreaStr()
		else
			do me.del(me.cursorX, me.cursorY, 1, true)
		end if
		do me.interpret1SetDirty(me.cursorY, true, false)
		do me.undoRecordEnd()
		do me.refreshCursor(false, true, true)
		do \form@paintDrawEditor(false)
	end func
	
	+*func cmdSelAll()
		do me.areaX :: 0
		do me.areaY :: 0
		do me.cursorX :: lib@intMax
		do me.cursorY :: lib@intMax
		do me.absoluteX :: 0
		do me.refreshCursor(false, true, true)
		do me.interpret1SetDirty(me.cursorY, false, false)
		do \form@paintDrawEditor(false)
	end func
	
	+*func undoImpl(undo2: \doc@UndoCmd)
		if(undo2 =$ UndoSrcIns)
			block
				var undo3: UndoSrcIns :: undo2 $ UndoSrcIns
				do me.ins(undo3.x, undo3.y, undo3.str, false)
			end block
		elif(undo2 =$ UndoSrcBsDel)
			block
				var undo3: UndoSrcBsDel :: undo2 $ UndoSrcBsDel
				switch(undo3.kind)
				case 0
					do me.bs(undo3.x, undo3.y, undo3.len, false)
				case 1
					do me.del(undo3.x, undo3.y, undo3.len, false)
				default
					assert false
				end switch
			end block
		elif(undo2 =$ UndoSrcInsLine)
			block
				var undo3: UndoSrcInsLine :: undo2 $ UndoSrcInsLine
				do me.insLine(undo3.x, undo3.y, undo3.str, false)
			end block
		elif(undo2 =$ UndoSrcDelLine)
			block
				var undo3: UndoSrcDelLine :: undo2 $ UndoSrcDelLine
				do me.delLine(undo3.x, undo3.y, false)
			end block
		elif(undo2 =$ UndoSrcCursor)
			block
				var undo3: UndoSrcCursor :: undo2 $ UndoSrcCursor
				do me.cursorX :: undo3.cursorX
				do me.cursorY :: undo3.cursorY
				do me.areaX :: undo3.areaX
				do me.areaY :: undo3.areaY
				do me.interpret1SetDirty(me.cursorY, true, false)
			end block
		else
			assert false
		end if
	end func
	
	+*func getSelCode(): []char
		if(!me.areaSel())
			ret null
		end if
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			var tmp: int
			do tmp :: x1
			do x1 :: x2
			do x2 :: tmp
			do tmp :: y1
			do y1 :: y2
			do y2 :: tmp
		end if
		var str: []char
		if(y1 = y2)
			do str :: me.src.src[y1].sub(x1, x2 - x1).trim()
		else
			do str :: me.src.src[y1].sub(x1, -1).trim() ~ "\n"
			for i(y1 + 1, y2 - 1)
				do str :~ me.src.src[i].trim() ~ "\n"
			end for
			do str :~ me.src.src[y2].sub(0, x2).trim()
		end if
		ret str
	end func
	
	+*func getCursorWord(): []char
		if(me.areaSel())
			var x1: int :: me.areaX
			var y1: int :: me.areaY
			var x2: int :: me.cursorX
			var y2: int :: me.cursorY
			if(y1 > y2 | y1 = y2 & x1 > x2)
				var tmp: int
				do tmp :: x1
				do x1 :: x2
				do x2 :: tmp
				do tmp :: y1
				do y1 :: y2
				do y2 :: tmp
			end if
			if(y1 = y2)
				ret me.src.src[y1].sub(x1, x2 - x1).trim()
			else
				ret me.src.src[y1].sub(x1, -1).trim()
			end if
		else
			var x1: int :: me.cursorX
			var x2: int :: x1
			var y1: int :: me.cursorY
			while loop(x1 > 0)
				var c: char :: me.src.src[y1][x1 - 1]
				if(!('a' <= c & c <= 'z' | 'A' <= c & c <= 'Z' | '0' <= c & c <= '9' | c = '@' | c = '_' | c = '\\'))
					break loop
				end if
				do x1 :- 1
			end while
			while loop(x2 < ^me.src.src[y1])
				var c: char :: me.src.src[y1][x2]
				if(!('a' <= c & c <= 'z' | 'A' <= c & c <= 'Z' | '0' <= c & c <= '9' | c = '@' | c = '_' | c = '\\'))
					break loop
				end if
				do x2 :+ 1
			end while
			ret x1 = x2 ?(null, me.src.src[y1].sub(x1, x2 - x1).trim())
		end if
	end func
	
	+*func updateUi()
		do \form@btnCode.setText(\common@langEn ?("Show Designer", "ãƒ‡ã‚¶ã‚¤ãƒŠã‚’è¡¨ç¤º"))
		do \form@btnCode.setEnabled(false)
		
		do \form@listLt.setVisible(true)
		do \form@listLt.setRedraw(false)
		do \form@listLt.clear()
		do \form@listLt.style(%list_)
		do \snippet@updateList(\form@listLt)
		do \form@listLt.setRedraw(true)
		
		do \form@treeLb.setVisible(true)
		do \form@treeLb.setRedraw(false)
		do \form@treeLb.clear()
		do \form@treeLb.expand(true)
		do \form@treeLb.setRedraw(true)
		
		do \form@listLb.setVisible(false)
		
		do \form@listRb.setVisible(true)
		do \form@listRb.setRedraw(false)
		do \form@listRb.clearAll()
		do \form@listRb.addColumn(\common@langEn ?("Error", "ã‚¨ãƒ©ãƒ¼"))
		do \form@listRb.adjustWidth()
		do me.errList.sort()
		for i(0, ^me.errList - 1)
			do \form@listRb.add(me.errList[i].text, -1)
		end for
		do \form@listRb.setRedraw(true)
		
		do \form@groupRbAr.setVisible(false)
	end func
	
	+*func onEvent(event: \doc@Event)
		switch(event)
		case %listLtOnMouseClick
			var sel: int :: \form@listLt.getSel()
			if(sel = -1)
				ret
			end if
			var code: []char :: \snippet@showPlace(\form@listLt.getText(&, sel, 0))
			if(code =& null)
				ret
			end if
			do me.undoRecordBegin()
			if(me.areaSel())
				do me.delAreaStr()
			end if
			do me.ins(me.cursorX, me.cursorY, code, true)
			do me.interpret1SetDirty(me.cursorY, true, false)
			do me.undoRecordEnd()
			do me.refreshCursor(false, true, true)
			do \form@paintDrawEditor(false)
		case %listRbOnMouseClick
			var sel: int :: \form@listRb.getSel()
			if(sel <> -1 & sel < ^me.errList)
				var item: @ErrListItem :: me.errList[sel]
				do \src@jumpSrc(item.pos)
			end if
		end switch
	end func
	
	+*func getChanged(): bool
		ret me.changed
	end func
	
	+func toggleBreakPoint()
		if(0 <= me.cursorY & me.cursorY < ^me.src.flags)
			if(me.src.flags[me.cursorY].and(%breakPoint) = %none)
				do me.src.flags[me.cursorY] :: me.src.flags[me.cursorY].or(%breakPoint)
			else
				do me.src.flags[me.cursorY] :: me.src.flags[me.cursorY].and((%breakPoint $ LineFlag).not())
			end if
			do \form@paintDrawEditor(false)
		end if
	end func
	
	+func setBreakPoint(y: int)
		if(0 <= y & y < ^me.src.flags)
			do me.src.flags[y] :: me.src.flags[y].or(%breakPoint)
		end if
	end func
	
	+func unsetBreakPoint(y: int)
		if(0 <= y & y < ^me.src.flags)
			do me.src.flags[y] :: me.src.flags[y].and((%breakPoint $ LineFlag).not())
		end if
	end func
	
	+func setSrc(src: [][]char)
		if(src =& null | ^src = 0)
			do me.src.src :: [""]
			do me.src.color :: [#[0]bit8]
			do me.src.commentLevel :: [0]
			do me.src.flags :: [%none $ LineFlag]
		else
			do me.src.src :: src
			do me.src.color :: #[^src][]bit8
			do me.src.commentLevel :: #[^src]int
			do me.src.flags :: #[^src]LineFlag
			for i(0, ^src - 1)
				do me.src.color[i] :: #[^src[i]]bit8
				do me.src.commentLevel[i] :: 0
				do me.src.flags[i] :: %none
			end for
		end if
	end func
	
	+func findPrev(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		var findBeginX: int :: (me.areaX <> -1 & me.areaX < me.cursorX ?(me.areaX, me.cursorX))
		var findBeginY: int :: me.cursorY
		var pos: int
		var found: []char
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret false
			end if
		end if
		for i(findBeginY, 0, -1)
			do pos :: @findStr(&found, me.src.src[i], true, 0, i = findBeginY ?(findBeginX - 1, ^me.src.src[i] - 1), pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.absoluteX :: 0
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
				ret true
			end if
		end for
		for i(^me.src.src - 1, findBeginY, -1)
			do pos :: @findStr(&found, me.src.src[i], true, i = findBeginY ?(findBeginX, 0), ^me.src.src[i] - 1, pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.absoluteX :: 0
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
				ret true
			end if
		end for
		ret false
	end func
	
	+func findNext(pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): bool
		var findBeginX: int :: (me.areaX <> -1 & me.areaX > me.cursorX ?(me.areaX, me.cursorX))
		var findBeginY: int :: me.cursorY
		var pos: int
		var found: []char
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret false
			end if
		end if
		for i(findBeginY, ^me.src.src - 1)
			do pos :: @findStr(&found, me.src.src[i], false, i = findBeginY ?(findBeginX, 0), ^me.src.src[i] - 1, pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.absoluteX :: 0
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
				ret true
			end if
		end for
		for i(0, findBeginY)
			do pos :: @findStr(&found, me.src.src[i], false, 0, i = findBeginY ?(findBeginX - 1, ^me.src.src[i] - 1), pattern, distinguishCase, onlyWord, regex)
			if(pos <> -1)
				do me.areaX :: pos
				do me.areaY :: i
				do me.cursorX :: pos + ^found
				do me.cursorY :: i
				do me.absoluteX :: 0
				do me.refreshCursor(false, true, true)
				do me.interpret1SetDirty(me.cursorY, false, false)
				do \form@paintDrawEditor(false)
				ret true
			end if
		end for
		ret false
	end func
	
	+func findSel(list_: wnd@List, poses: list<\src@Pos>, srcName: []char, pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
		if(!me.areaSel())
			ret
		end if
		var areaX1: int :: me.cursorX
		var areaY1: int :: me.cursorY
		var areaX2: int :: me.areaX
		var areaY2: int :: me.areaY
		if(areaY1 > areaY2 | areaY1 = areaY2 & areaX1 > areaX2)
			var tmp: int
			do tmp :: areaX1
			do areaX1 :: areaX2
			do areaX2 :: tmp
			do tmp :: areaY1
			do areaY1 :: areaY2
			do areaY2 :: tmp
		end if
		do me.cursorX :: areaX1
		do me.cursorY :: areaY1
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		while loop(true)
			var oldX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var oldY: int :: me.cursorY
			if(!me.findNext(pattern, distinguishCase, onlyWord, regularExpression))
				break loop
			end if
			var newX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var newY: int :: me.cursorY
			if(newY < oldY | newY = oldY & newX <= oldX | newY > areaY2 | newY = areaY2 & newX + ^pattern > areaX2)
				break loop
			end if
			do list_.add("[" ~ srcName ~ ": " ~ (newY + 1).toStr() ~ ", " ~ (newX + 1).toStr() ~ "]")
			var pos: \src@Pos :: #\src@Pos
			do pos.src :: srcName
			do pos.row :: newY + 1
			do pos.col :: newX + 1
			do poses.add(pos)
		end while
	end func
	
	+func findAll(list_: wnd@List, poses: list<\src@Pos>, srcName: []char, pattern: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		while loop(true)
			var oldX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var oldY: int :: me.cursorY
			if(!me.findNext(pattern, distinguishCase, onlyWord, regularExpression))
				break loop
			end if
			var newX: int :: me.cursorX < me.areaX ?(me.cursorX, me.areaX)
			var newY: int :: me.cursorY
			if(newY < oldY | newY = oldY & newX <= oldX)
				break loop
			end if
			do list_.add("[" ~ srcName ~ ": " ~ (newY + 1).toStr() ~ ", " ~ (newX + 1).toStr() ~ "]")
			var pos: \src@Pos :: #\src@Pos
			do pos.src :: srcName
			do pos.row :: newY + 1
			do pos.col :: newX + 1
			do poses.add(pos)
		end while
	end func
	
	+func replaceOne(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool)
		if(!me.areaSel() | me.areaY <> me.cursorY)
			ret
		end if
		var x1: int :: me.areaX
		var x2: int :: me.cursorX
		if(x1 > x2)
			var tmp: int :: x1
			do x1 :: x2
			do x2 :: tmp
		end if
		var regex: regex@Regex :: null
		if(regularExpression)
			do regex :: regex@makeRegex(pattern)
			if(regex =& null)
				ret
			end if
		end if
		var found: []char
		var pos: int :: @findStr(&found, me.src.src[me.cursorY], false, x1, x1, pattern, distinguishCase, onlyWord, regex)
		if(pos = x1)
			if(regex <>& null)
				do replaceStr :: regex.replace(found, replaceStr, false)
			end if
			var record: bool :: !me.undo.recording()
			if(record)
				do me.undo.recordBegin()
			end if
			do me.del(x1, me.cursorY, ^found, true)
			do me.ins(x1, me.cursorY, replaceStr, true)
			do me.interpret1SetDirty(me.cursorY, true, false)
			if(record)
				do me.undo.recordEnd()
			end if
		end if
	end func
	
	+func replaceSel(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): int
		if(!me.areaSel())
			ret 0
		end if
		var area0: SelArea :: me.getSelArea()
		var area: SelArea :: ##area0
		var swapFlag: bool :: area.normalize()
		do me.cursorX :: area.x1
		do me.cursorY :: area.y1
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		var cnt: int :: 0
		var areaOld: SelArea :: me.getSelArea()
		do areaOld.normalize()
		while loop(true)
			if(!me.findNext(pattern, distinguishCase, onlyWord, regularExpression))
				break loop
			end if
			var areaNew: SelArea :: me.getSelArea()
			do areaNew.normalize()
			if(areaNew.y1 < areaOld.y1 | areaNew.y1 = areaOld.y1 & areaNew.x1 < areaOld.x1 | areaNew.y2 > area.y2 | areaNew.y2 = area.y2 & areaNew.x2 > area.x2)
				break loop
			end if
			if(cnt = 0)
				var areaCur: SelArea :: me.getSelArea()
				do me.setSelArea(area0)
				do me.undoRecordBegin()
				do me.setSelArea(areaCur)
			end if
			do me.replaceOne(pattern, replaceStr, distinguishCase, onlyWord, regularExpression)
			do areaOld :: me.getSelArea()
			do areaOld.normalize()
			do area.y2 :+ areaOld.y2 - areaNew.y2
			if(area.y2 = areaOld.y2)
				do area.x2 :+ areaOld.x2 - areaNew.x2
			end if
			do cnt :+ 1
		end while
		if(cnt = 0)
			do me.setSelArea(area0)
		else
			if(swapFlag)
				do area.swap()
			end if
			do me.setSelArea(area)
			do me.undoRecordEnd()
		end if
		ret cnt
	end func
	
	+func replaceAll(pattern: []char, replaceStr: []char, distinguishCase: bool, onlyWord: bool, regularExpression: bool): int
		var area0: SelArea :: me.getSelArea()
		do me.cursorX :: 0
		do me.cursorY :: 0
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		var cnt: int :: 0
		while loop(true)
			var areaOld: SelArea :: me.getSelArea()
			do areaOld.normalize()
			if(!me.findNext(pattern, distinguishCase, onlyWord, regularExpression))
				break loop
			end if
			var areaNew: SelArea :: me.getSelArea()
			do areaNew.normalize()
			if(areaNew.y1 < areaOld.y1 | areaNew.y1 = areaOld.y1 & areaNew.x1 < areaOld.x1)
				break loop
			end if
			if(cnt = 0)
				var areaCur: SelArea :: me.getSelArea()
				do me.setSelArea(area0)
				do me.undoRecordBegin()
				do me.setSelArea(areaCur)
			end if
			do me.replaceOne(pattern, replaceStr, distinguishCase, onlyWord, regularExpression)
			do cnt :+ 1
		end while
		if(cnt <> 0)
			do me.undoRecordEnd()
		end if
		ret cnt
	end func
	
	+func move(col: int, row: int)
		do me.cursorX :: col
		do me.cursorY :: row
		do me.areaX :: -1
		do me.areaY :: -1
		do me.absoluteX :: 0
		do me.refreshCursor(false, true, true)
		do me.interpret1SetDirty(me.cursorY, false, false)
	end func
	
	+func complementDecision(): bool
		ret me.complementImpl()
	end func
	
	+func resetListInfoItem()
		do me.errList :: #[0]@ErrListItem
	end func
	
	+func addListInfoItem(item: @ErrListItem)
		do me.errList :~ [item]
	end func
	
	+func replaceForAuxiliary(line: int, str: []char)
		if(line >= 0)
			do me.del(0, line, ^me.src.src[line], true)
			do me.ins(0, line, ##str, true)
		else
			do line :: -1 - line
			do me.ins(^me.src.src[line], line, ##str, true)
			do me.forceToInterpret1 :: false
		end if
	end func
	
	+func getBreakPoints(srcName: []char, poses: list<\src@Pos>)
		for i(0, ^me.src.flags - 1)
			if(me.src.flags[i].and(%breakPoint) <> %none)
				var pos: \src@Pos :: #\src@Pos
				do pos.src :: srcName
				do pos.row :: i + 1
				do pos.col :: 1
				do poses.add(pos)
			end if
		end for
	end func
	
	+func setLock(enabled: bool)
		do me.lock :: enabled
	end func
	
	const colorLineNum: int :: 0xFFFF7F7F
	const colorAreaBack: int :: 0xFF808080
	const colorErrBack: int :: 0xFFFF3333
	const colorBreakPointBack: int :: 0xFFFF9999
	const colorBreakPoint: int :: 0xFFFFFFFF
	const colorBreakBack: int :: 0xFFCCCC99
	
	enum LineFlag
		none :: 0x00
		nextLine :: 0x01
		breakPoint :: 0x02
	end enum
	
	class Src()
		+var src: [][]char
		+var color: [][]bit8
		+var commentLevel: []int
		+var flags: []LineFlag
	end class
	
	class UndoSrc(\doc@UndoCmd)
		+*func cmd()
			do me.doc.undoImpl(me)
		end func
	end class
	
	class UndoSrcIns(UndoSrc)
		+var x: int
		+var y: int
		+var str: []char
	end class
	
	class UndoSrcBsDel(UndoSrc)
		+var kind: int {0=bs, 1=del}
		+var x: int
		+var y: int
		+var len: int
	end class
	
	class UndoSrcInsLine(UndoSrc)
		+var x: int
		+var y: int
		+var str: []char
	end class
	
	class UndoSrcDelLine(UndoSrc)
		+var x: int
		+var y: int
	end class
	
	class UndoSrcCursor(UndoSrc)
		+var cursorX: int
		+var cursorY: int
		+var areaX: int
		+var areaY: int
	end class
	
	class UndoSrcReplaceAll(UndoSrc)
		+var x: []int
		+var y: []int
		+var len: []int
		+var str: [][]char
	end class
	
	+var src: Src
	var pageX: int
	var pageY: int
	var cursorX: int
	var cursorY: int
	var areaX: int
	var areaY: int
	var absoluteX: int
	var lineNumWidth: int
	+var errList: []@ErrListItem
	var dirtyLine: int
	var forceToInterpret1: bool
	var caretX: int
	var caretY: int
	var caretShown: bool
	var sys: bool
	var lock: bool
	
	func areaSel(): bool
		ret me.areaX <> -1 & (me.areaX <> me.cursorX | me.areaY <> me.cursorY)
	end func
	
	class SelArea()
		+var x1: int
		+var y1: int
		+var x2: int
		+var y2: int
		+func normalize(): bool
			if(me.y1 > me.y2 | me.y1 = me.y2 & me.x1 > me.x2)
				do me.swap()
				ret true
			end if
			ret false
		end func
		+func swap()
			var tmp: int
			do tmp :: me.x1
			do me.x1 :: me.x2
			do me.x2 :: tmp
			do tmp :: me.y1
			do me.y1 :: me.y2
			do me.y2 :: tmp
		end func
	end class
	
	func getSelArea(): SelArea
		var area: SelArea :: #SelArea
		do area.x1 :: me.areaX
		do area.y1 :: me.areaY
		do area.x2 :: me.cursorX
		do area.y2 :: me.cursorY
		ret area
	end func
	
	func setSelArea(area: SelArea)
		do me.areaX :: area.x1
		do me.areaY :: area.y1
		do me.cursorX :: area.x2
		do me.cursorY :: area.y2
	end func
	
	func charWidth(c: char, x: int): int
		if(c = '\t')
			ret 4 - x % 4
		elif(c $ int <= 0x1F)
			ret 0
		elif(c $ int <= 0x7E)
			ret 1
		elif(c $ int <= 0xA0)
			ret 0
		end if
		ret 2
	end func
	
	func setArea(shiftCtrl: wnd@ShiftCtrl)
		if(shiftCtrl.and(%shift) <> %none)
			if(!me.areaSel())
				do me.areaX :: me.cursorX
				do me.areaY :: me.cursorY
			end if
			do \form@paintDrawEditor(false)
		else
			if(me.areaX <> -1)
				do me.areaX :: -1
				do \form@paintDrawEditor(false)
			end if
		end if
	end func
	
	func mousePosToCharPos(mouseX: int, mouseY: int)
		do me.cursorY :: me.pageY + mouseY / \common@cellHeight
		if(me.cursorY < 0)
			do me.cursorY :: 0
		end if
		if(me.cursorY >= ^me.src.src)
			do me.cursorY :: ^me.src.src - 1
		end if
		var left: int :: me.lineNumWidth - me.pageX * \common@cellWidth
		var x: int :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(mouseX < left + (x + charWidth2) * \common@cellWidth)
				do me.cursorX :: i
				ret
			end if
			do x :+ charWidth2
		end for
		do me.cursorX :: ^me.src.src[me.cursorY]
	end func
	
	func refreshCursor(moveRight: bool, refreshScroll: bool, refreshScrollPos: bool)
		var scrWidth: int
		var scrHeight: int
		do \form@drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		do me.lineNumWidth :: \common@cellWidth * (lib@max(log10(^me.src.src), 3) + 1)
		
		if(me.cursorX < 0)
			if(me.cursorY = 0)
				do me.cursorX :: 0
			else
				do me.cursorX :: lib@intMax
				do me.cursorY :- 1
			end if
		end if
		if(me.cursorY < 0)
			do me.cursorY :: 0
		end if
		if(me.cursorY > ^me.src.src - 1)
			do me.cursorY :: ^me.src.src - 1
			do me.cursorX :: lib@min(me.cursorX, ^me.src.src[me.cursorY])
		else
			if(me.cursorX > ^me.src.src[me.cursorY])
				if(moveRight & me.cursorY <> ^me.src.src - 1)
					do me.cursorX :: 0
					do me.cursorY :+ 1
				else
					do me.cursorX :: ^me.src.src[me.cursorY]
				end if
			end if
		end if
		if(!\form@dragging() & me.areaX = me.cursorX & me.areaY = me.cursorY)
			do me.areaX :: -1
		end if
		
		if(refreshScroll)
			var paint: bool :: false
			var paddingX: int :: (me.lineNumWidth + 17) / \common@cellWidth + 1
			const paddingY: int :: 17 / \common@cellHeight + 1
			if(refreshScrollPos)
				if(me.pageY > me.cursorY)
					do me.pageY :: me.cursorY
					do paint :: true
				end if
				if(me.pageY < me.cursorY - scrHeight / \common@cellHeight + paddingY + 1)
					do me.pageY :: me.cursorY - scrHeight / \common@cellHeight + paddingY + 1
					do paint :: true
				end if
			end if
			do \form@scrollYSrc.setState(0, ^me.src.src - 1 + paddingY, scrHeight / \common@cellHeight, me.pageY)
			var maxX: int :: 0
			for i(0, scrHeight / \common@cellHeight + 1)
				if(me.pageY + i >= ^me.src.src)
					break i
				end if
				var x: int :: 0
				var str: []char :: me.src.src[me.pageY + i]
				for j(0, ^str - 1)
					do x :+ me.charWidth(str[j], x)
				end for
				if(maxX < x)
					do maxX :: x
				end if
			end for
			block
				var x: int :: 0
				for i(0, ^me.src.src[me.cursorY] - 1)
					if(i >= me.cursorX)
						break i
					end if
					do x :+ me.charWidth(me.src.src[me.cursorY][i], x)
				end for
				if(refreshScrollPos)
					if(me.pageX > x)
						do me.pageX :: x
						do paint :: true
					end if
					if(me.pageX < x - scrWidth / \common@cellWidth + paddingX + 1)
						do me.pageX :: x - scrWidth / \common@cellWidth + paddingX + 1
						do paint :: true
					end if
				end if
			end block
			do \form@scrollXSrc.setState(0, maxX - 1 + paddingX, scrWidth / \common@cellWidth, me.pageX)
			if(paint)
				do \form@paintDrawEditor(false)
			end if
		end if
		
		block
			var x: int :: 0
			var str: []char :: me.src.src[me.cursorY]
			for i(0, me.cursorX - 1)
				do x :+ me.charWidth(str[i], x)
			end for
			do x :: me.lineNumWidth + (x - me.pageX) * \common@cellWidth
			var y: int :: (me.cursorY - me.pageY) * \common@cellHeight
			if(x + 2 <= 0 | scrWidth - 17 <= x | y + \common@cellHeight <= 0 | scrHeight - 17 <= y)
				do me.caretX :: -1
				do me.caretY :: -1
				do \form@drawEditor.moveCaret(-1, -1)
			else
				do me.caretX :: x
				do me.caretY :: y
				do \form@drawEditor.moveCaret(x, y)
			end if
		end block
		
		do \completion@updatePos()
		
		func log10(n: int): int
			var result: int :: 0
			var m: int :: 1
			while(n >= m)
				do m :* 10
				do result :+ 1
			end while
			ret result
		end func
	end func
	
	func getAbsoluteX(): int
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret 0
		end if
		var absoluteX: int :: 0
		for i(0, me.cursorX - 1)
			if(i >= ^me.src.src[me.cursorY])
				break i
			end if
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], absoluteX)
			do absoluteX :+ charWidth2
		end for
		do me.absoluteX :: lib@max(me.absoluteX, absoluteX)
		ret me.absoluteX
	end func
	
	func setAbsoluteX(absoluteX: int)
		if(me.cursorY < 0 | ^me.src.src <= me.cursorY)
			ret
		end if
		var x: int :: 0
		do me.cursorX :: 0
		for i(0, ^me.src.src[me.cursorY] - 1)
			var charWidth2: int :: me.charWidth(me.src.src[me.cursorY][i], x)
			if(x + charWidth2 > absoluteX)
				break i
			end if
			do x :+ charWidth2
			do me.cursorX :+ 1
		end for
		do me.absoluteX :: lib@max(me.absoluteX, x)
	end func
	
	func copyAreaStr()
		assert me.areaSel()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			var tmp: int
			do tmp :: x1
			do x1 :: x2
			do x2 :: tmp
			do tmp :: y1
			do y1 :: y2
			do y2 :: tmp
		end if
		var str: []char
		if(y1 = y2)
			do str :: me.src.src[y1].sub(x1, x2 - x1)
		else
			do str :: me.src.src[y1].sub(x1, -1) ~ "\n"
			for i(y1 + 1, y2 - 1)
				do str :~ me.src.src[i] ~ "\n"
			end for
			do str :~ me.src.src[y2].sub(0, x2)
		end if
		do @setClipboardStr(str)
	end func
	
	func copyLineStr()
		do @setClipboardStr(me.src.src[me.cursorY] ~ "\n")
		for i(0, ^@lineClipboardFormats - 1)
			do @setClipboard(@lineClipboardFormats[i], [1b8])
		end for
	end func
	
	func delAreaStr()
		assert me.areaSel()
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			var tmp: int
			do tmp :: x1
			do x1 :: x2
			do x2 :: tmp
			do tmp :: y1
			do y1 :: y2
			do y2 :: tmp
		end if
		var len: int
		if(y1 = y2)
			do len :: x2 - x1
		else
			do len :: ^me.src.src[y1] - x1 + 1
			for i(y1 + 1, y2 - 1)
				do len :+ ^me.src.src[i] + 1
			end for
			do len :+ x2
		end if
		do me.cursorX :: x1
		do me.cursorY :: y1
		do me.del(me.cursorX, me.cursorY, len, true)
		do me.areaX :: -1
	end func
	
	func indentAreaStr()
		assert me.areaSel()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			var tmp: int
			do tmp :: x1
			do x1 :: x2
			do x2 :: tmp
			do tmp :: y1
			do y1 :: y2
			do y2 :: tmp
		end if
		if(x2 = 0)
			do y2 :- 1
		end if
		do me.undoRecordBegin()
		for i(y1, y2)
			if(^me.src.src[i] <> 0)
				if(i = oldAreaY)
					do oldAreaX :+ 1
				end if
				if(i = oldCursorY)
					do oldCursorX :+ 1
				end if
				do me.ins(0, i, "\t", true)
			end if
		end for
		do me.interpret1SetDirty(y2, true, false)
		do me.undoRecordEnd()
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func
	
	func unindentAreaStr()
		assert me.areaSel()
		var oldAreaX: int :: me.areaX
		var oldAreaY: int :: me.areaY
		var oldCursorX: int :: me.cursorX
		var oldCursorY: int :: me.cursorY
		var x1: int :: me.areaX
		var y1: int :: me.areaY
		var x2: int :: me.cursorX
		var y2: int :: me.cursorY
		if(y1 > y2 | y1 = y2 & x1 > x2)
			var tmp: int
			do tmp :: x1
			do x1 :: x2
			do x2 :: tmp
			do tmp :: y1
			do y1 :: y2
			do y2 :: tmp
		end if
		if(x2 = 0)
			do y2 :- 1
		end if
		do me.undoRecordBegin()
		for i(y1, y2)
			if(^me.src.src[i] > 0 & me.src.src[i][0] = '\t')
				if(i = oldAreaY & oldAreaX > 0 & oldAreaX < ^me.src.src[i] & me.src.src[i][oldAreaX] <> '\t')
					do oldAreaX :- 1
				end if
				if(i = oldCursorY & oldCursorX > 0 & oldCursorX < ^me.src.src[i] & me.src.src[i][oldCursorX] <> '\t')
					do oldCursorX :- 1
				end if
				do me.del(0, i, 1, true)
			end if
		end for
		do me.interpret1SetDirty(y2, true, false)
		do me.undoRecordEnd()
		do me.areaX :: oldAreaX
		do me.areaY :: oldAreaY
		do me.cursorX :: oldCursorX
		do me.cursorY :: oldCursorY
	end func
	
	func ins(x: int, y: int, str: []char, recordUndo: bool)
		var redo: UndoSrcIns
		if(recordUndo)
			do redo :: #UndoSrcIns
			do redo.doc :: me
			do redo.x :: x
			do redo.y :: y
			do redo.str :: str
		end if
		for i(0, ^str - 1)
			if(str[i] = '\n')
				var line: []char :: me.src.src[y].sub(x, -1)
				do me.src.src[y] :: me.src.src[y].sub(0, x)
				do me.src.color[y] :: me.src.color[y].sub(0, x)
				do me.src.src :: me.src.src.sub(0, y + 1) ~ [line] ~ me.src.src.sub(y + 1, -1)
				do me.src.color :: me.src.color.sub(0, y + 1) ~ [#[^line]bit8] ~ me.src.color.sub(y + 1, -1)
				do me.src.commentLevel :: me.src.commentLevel.sub(0, y + 1) ~ [0] ~ me.src.commentLevel.sub(y + 1, -1)
				do me.src.flags :: me.src.flags.sub(0, y + 1) ~ [%none $ LineFlag] ~ me.src.flags.sub(y + 1, -1)
				do x :: 0
				do y :+ 1
				do me.forceToInterpret1 :: true
			else
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ str[i].toStr() ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: me.src.color[y].sub(0, x) ~ #[1]bit8 ~ me.src.color[y].sub(x, -1)
				do x :+ 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcBsDel :: #UndoSrcBsDel
			do undo.doc :: me
			do undo.kind :: 0
			do undo.x :: x
			do undo.y :: y
			do undo.len :: ^str
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do me.absoluteX :: 0
		do me.changed :: true
	end func
	
	func insLine(x: int, y: int, str: []char, recordUndo: bool)
		var redo: UndoSrcInsLine
		if(recordUndo)
			do redo :: #UndoSrcInsLine
			do redo.doc :: me
			do redo.x :: x
			do redo.y :: y
			do redo.str :: str
		end if
		do me.ins(0, y, str, false)
		do me.cursorX :: x
		if(recordUndo)
			var undo: UndoSrcDelLine :: #UndoSrcDelLine
			do undo.doc :: me
			do undo.x :: x
			do undo.y :: y
			do me.undo.add(undo, redo)
		end if
		do me.absoluteX :: 0
		do me.changed :: true
	end func
	
	func bs(x: int, y: int, len: int, recordUndo: bool)
		var redo: UndoSrcBsDel
		if(recordUndo)
			do redo :: #UndoSrcBsDel
			do redo.doc :: me
			do redo.kind :: 0
			do redo.x :: x
			do redo.y :: y
			do redo.len :: len
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = 0)
				if(y <> 0)
					do undoStr :: "\n" ~ undoStr
					var x2: int :: ^me.src.src[y - 1]
					do me.src.src[y - 1] :~ me.src.src[y]
					do me.src.color[y - 1] :~ me.src.color[y]
					do me.src.src :: me.src.src.sub(0, y) ~ me.src.src.sub(y + 1, -1)
					do me.src.color :: me.src.color.sub(0, y) ~ me.src.color.sub(y + 1, -1)
					do me.src.commentLevel :: me.src.commentLevel.sub(0, y) ~ me.src.commentLevel.sub(y + 1, -1)
					do me.src.flags :: me.src.flags.sub(0, y) ~ me.src.flags.sub(y + 1, -1)
					do y :- 1
					do x :: x2
					do me.forceToInterpret1 :: true
				end if
			else
				do undoStr :: me.src.src[y][x - 1].toStr() ~ undoStr
				do me.src.src[y] :: me.src.src[y].sub(0, x - 1) ~ me.src.src[y].sub(x, -1)
				do me.src.color[y] :: me.src.color[y].sub(0, x - 1) ~ me.src.color[y].sub(x, -1)
				do x :- 1
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcIns :: #UndoSrcIns
			do undo.doc :: me
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do me.absoluteX :: 0
		do me.changed :: true
	end func
	
	func del(x: int, y: int, len: int, recordUndo: bool)
		var redo: UndoSrcBsDel
		if(recordUndo)
			do redo :: #UndoSrcBsDel
			do redo.doc :: me
			do redo.kind :: 1
			do redo.x :: x
			do redo.y :: y
			do redo.len :: len
		end if
		var undoStr: []char :: ""
		for(1, len)
			if(x = ^me.src.src[y])
				if(y <> ^me.src.src - 1)
					do undoStr :~ "\n"
					do me.src.src[y] :~ me.src.src[y + 1]
					do me.src.color[y] :~ me.src.color[y + 1]
					do me.src.src :: me.src.src.sub(0, y + 1) ~ me.src.src.sub(y + 2, -1)
					do me.src.color :: me.src.color.sub(0, y + 1) ~ me.src.color.sub(y + 2, -1)
					do me.src.commentLevel :: me.src.commentLevel.sub(0, y + 1) ~ me.src.commentLevel.sub(y + 2, -1)
					do me.src.flags :: me.src.flags.sub(0, y + 1) ~ me.src.flags.sub(y + 2, -1)
					do me.forceToInterpret1 :: true
				end if
			else
				do undoStr :~ me.src.src[y][x].toStr()
				do me.src.src[y] :: me.src.src[y].sub(0, x) ~ me.src.src[y].sub(x + 1, -1)
				do me.src.color[y] :: me.src.color[y].sub(0, x) ~ me.src.color[y].sub(x + 1, -1)
			end if
		end for
		if(recordUndo)
			var undo: UndoSrcIns :: #UndoSrcIns
			do undo.doc :: me
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.undo.add(undo, redo)
		end if
		do me.cursorX :: x
		do me.cursorY :: y
		do me.absoluteX :: 0
		do me.changed :: true
	end func
	
	func delLine(x: int, y: int, recordUndo: bool)
		var redo: UndoSrcDelLine
		if(recordUndo)
			do redo :: #UndoSrcDelLine
			do redo.doc :: me
			do redo.x :: x
			do redo.y :: y
		end if
		var undoStr: []char :: me.src.src[y] ~ (y = ^me.src.src - 1 ?("", "\n"))
		do me.cursorX :: x
		do me.cursorY :: y
		var absoluteX: int :: me.getAbsoluteX()
		do me.del(0, y, ^me.src.src[y] + 1, false)
		do me.setAbsoluteX(absoluteX)
		if(recordUndo)
			var undo: UndoSrcInsLine :: #UndoSrcInsLine
			do undo.doc :: me
			do undo.x :: x
			do undo.y :: y
			do undo.str :: undoStr
			do me.undo.add(undo, redo)
		end if
		do me.absoluteX :: 0
		do me.changed :: true
	end func
	
	func scrollPageX(wheel: int)
		do me.pageX :+ wheel
		; TODO: me.pageX >= ?
		if(me.pageX < 0)
			do me.pageX :: 0
		end if
		do me.refreshCursor(false, false, false)
		do \form@scrollXSrc.setScrollPos(me.pageX)
		do \form@paintDrawEditor(false)
	end func
	
	func scrollPageY(wheel: int)
		do me.pageY :+ wheel
		const paddingY: int :: 17 / \common@cellHeight + 1
		var scrWidth: int
		var scrHeight: int
		do \form@drawEditor.getPos(&, &, &scrWidth, &scrHeight)
		if(me.pageY >= ^me.src.src - scrHeight / \common@cellHeight + paddingY)
			do me.pageY :: ^me.src.src - scrHeight / \common@cellHeight + paddingY
		end if
		if(me.pageY < 0)
			do me.pageY :: 0
		end if
		do me.refreshCursor(false, false, false)
		do \form@scrollYSrc.setScrollPos(me.pageY)
		do \form@paintDrawEditor(false)
	end func
	
	func skipTabs(y: int): int
		var x: int :: 0
		while(x < ^me.src.src[y] & me.src.src[y][x] = '\t')
			do x :+ 1
		end while
		ret x = ^me.src.src[y] ?(-1, x)
	end func
	
	func interpret1SetDirty(line: int, modified: bool, showCompletion: bool)
		if(me.sys)
			ret
		end if
		var record: bool :: !me.undo.recording()
		if(record)
			do me.undo.recordBegin()
		end if
		if(me.dirtyLine = -1 & !me.forceToInterpret1)
			if(modified)
				do me.dirtyLine :: line
				do \dll@interpret1(me.src, me.dirtyLine, me, me.replaceForAuxiliary, me.cursorX, me.cursorY, &, 0, 0)
				do \form@paintDrawEditor(false)
			end if
		else
			if(me.dirtyLine <> line | me.forceToInterpret1)
				do me.forceToInterpret1 :: false
				do \completion@close()
				var newX: int
				var newY: int :: me.cursorY
				do \dll@interpret1(me.src, -1, me, me.replaceForAuxiliary, me.cursorX, me.cursorY, &newX, me.dirtyLine, modified ?(me.cursorY, me.dirtyLine))
				do me.cursorX :: newX
				do me.cursorY :: newY
				do me.refreshCursor(false, true, true)
				
				if(me.dirtyLine <> line)
					do \form@callInterpret2()
				end if
				
				do me.dirtyLine :: -1
				do \form@paintDrawEditor(false)
			else
				if(modified)
					do \dll@interpret1(me.src, me.dirtyLine, me, me.replaceForAuxiliary, me.cursorX, me.cursorY, &, 0, 0)
					do \form@paintDrawEditor(false)
				end if
			end if
		end if
		if(record)
			do me.undo.recordEnd()
		end if
		
		if(showCompletion & modified)
			var first: int
			var word: []char :: me.parseWord(me.cursorX, me.cursorY, &first)
			do \form@drawEditor.showCaret(\common@cellHeight, \common@font.handle())
			do \completion@show(me.src, \src@curDocName, first, me.cursorY, word)
			do \form@drawEditor.hideCaret()
		end if
	end func
	
	func parseWord(x: int, y: int, first: &int): []char
		do first :: x
		while(first > 0 & keyword(me.src.color[y][first - 1]))
			do first :- 1
		end while
		if(first = ^me.src.color[y] | !keyword(me.src.color[y][first]))
			do first :: x
			ret null
		end if
		var last: int :: x
		while(last < ^me.src.color[y] & keyword(me.src.color[y][last]))
			do last :+ 1
		end while
		ret me.src.src[y].sub(first, last - first).trim()
		
		func keyword(color: bit8): bool
			do color :: color.and(0x7Fb8)
			ret color = %identifier $ @CharColor $ bit8 | color = %global $ @CharColor $ bit8 | color = %reserved $ @CharColor $ bit8
		end func
	end func
	
	func complementImpl(): bool
		var replaceStr: []char :: \completion@getSelWord()
		if(replaceStr =& null)
			ret false
		end if
		var first: int
		var word: []char :: me.parseWord(me.cursorX, me.cursorY, &first)
		if(word <>& null & word <> replaceStr)
			do me.cursorX :: first
			do me.areaX :: first + ^word
			do me.areaY :: me.cursorY
			do me.replaceOne(word, replaceStr, true, false, false)
			do me.cursorX :: first + ^replaceStr
			do me.areaX :: -1
			do me.areaY :: -1
			do me.refreshCursor(false, true, true)
			do \form@paintDrawEditor(false)
		end if
		do \completion@close()
		ret true
	end func
	
	func locked(): bool
		if(\form@getLockingEditor())
			do \form@showMsgRunning()
			ret true
		end if
		ret me.lock
	end func
	
	func undoRecordBegin()
		do me.undo.recordBegin()
		
		var undo: UndoSrcCursor :: #UndoSrcCursor
		do undo.doc :: me
		do undo.cursorX :: me.cursorX
		do undo.cursorY :: me.cursorY
		do undo.areaX :: me.areaX
		do undo.areaY :: me.areaY
		do me.undo.add(undo, undo)
	end func
	
	func undoRecordEnd()
		var undo: UndoSrcCursor :: #UndoSrcCursor
		do undo.doc :: me
		do undo.cursorX :: me.cursorX
		do undo.cursorY :: me.cursorY
		do undo.areaX :: me.areaX
		do undo.areaY :: me.areaY
		do me.undo.add(undo, undo)
		
		do me.undo.recordEnd()
	end func
end class

func findStr(found: &[]char, text: []char, fromLast: bool, first: int, last: int, pattern: []char, distinguishCase: bool, onlyWord: bool, regex: regex@Regex): int
	var pos: int
	if(regex =& null)
		do pos :: text.findStrEx(pattern, fromLast ?(last, first), fromLast, !distinguishCase, onlyWord)
		if(pos < first | last < pos)
			do pos :: -1
		end if
		do found :: pattern
		ret pos
	else
		var word: [][]char
		if(fromLast)
			do word :: regex.findLast(&pos, text, last)
		else
			do word :: regex.find(&pos, text, first)
		end if
		if(pos <> -1)
			do found :: word[0]
		end if
		ret pos
	end if
	ret -1
end func

func setClipboardStr(str: []char)
	for(1, 10)
		if(wnd@setClipboardStr(str))
			ret
		end if
		do lib@sleep(1)
	end for
end func

func setClipboard(format: int, str: []bit8)
	for(1, 10)
		if(wnd@setClipboard(format, str))
			ret
		end if
		do lib@sleep(1)
	end for
end func
